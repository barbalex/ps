import { store, syncingAtom } from '../store.ts'
import { constants } from './constants.ts'

const url = constants.getElectricUri()

const tablesSyncData = [
  {
    table: 'users',
    columns: ['user_id', 'email', 'created_at', 'updated_at', 'updated_by'],
    primaryKey: ['user_id'],
  },
  { table: 'accounts', primaryKey: ['account_id'] },
  { table: 'project_types', primaryKey: ['type'] },
  { table: 'projects', primaryKey: ['project_id'] },
  {
    table: 'place_levels',
    columns: [
      'place_level_id',
      'account_id',
      'project_id',
      'level',
      'name_singular',
      'name_plural',
      'name_short',
      'reports',
      'report_values',
      'actions',
      'action_values',
      'action_reports',
      'checks',
      'check_values',
      'check_taxa',
      'occurrences',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['place_level_id'],
  },
  {
    table: 'subprojects',
    columns: [
      'subproject_id',
      'account_id',
      'project_id',
      'name',
      'start_year',
      'end_year',
      'data',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['subproject_id'],
  },
  { table: 'user_roles', primaryKey: ['role'] },
  { table: 'project_users', primaryKey: ['project_user_id'] },
  { table: 'subproject_users', primaryKey: ['subproject_user_id'] },
  { table: 'taxonomy_types', primaryKey: ['type'] },
  {
    table: 'taxonomies',
    columns: [
      'taxonomy_id',
      'account_id',
      'project_id',
      'type',
      'name',
      'url',
      'obsolete',
      'data',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['taxonomy_id'],
  },
  { table: 'taxa', primaryKey: ['taxon_id'] },
  { table: 'subproject_taxa', primaryKey: ['subproject_taxon_id'] },
  {
    table: 'lists',
    columns: [
      'list_id',
      'account_id',
      'project_id',
      'name',
      'data',
      'obsolete',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['list_id'],
  },
  {
    table: 'list_values',
    columns: [
      'list_value_id',
      'account_id',
      'list_id',
      'value',
      'obsolete',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['list_value_id'],
  },
  { table: 'unit_types', primaryKey: ['type'] },
  {
    table: 'units',
    columns: [
      'unit_id',
      'account_id',
      'project_id',
      'use_for_action_values',
      'use_for_action_report_values',
      'use_for_check_values',
      'use_for_place_report_values',
      'use_for_goal_report_values',
      'use_for_subproject_taxa',
      'use_for_check_taxa',
      'name',
      'summable',
      'sort',
      'type',
      'list_id',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['unit_id'],
  },
  { table: 'places', primaryKey: ['place_id'] },
  {
    table: 'actions',
    columns: [
      'action_id',
      'account_id',
      'place_id',
      'date',
      'data',
      'geometry',
      'bbox',
      'relevant_for_reports',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['action_id'],
  },
  { table: 'action_values', primaryKey: ['action_value_id'] },
  {
    table: 'action_reports',
    columns: [
      'action_report_id',
      'account_id',
      'action_id',
      'year',
      'data',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['action_report_id'],
  },
  { table: 'action_report_values', primaryKey: ['action_report_value_id'] },
  {
    table: 'checks',
    columns: [
      'check_id',
      'account_id',
      'place_id',
      'date',
      'data',
      'geometry',
      'bbox',
      'relevant_for_reports',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['check_id'],
  },
  { table: 'check_values', primaryKey: ['check_value_id'] },
  { table: 'check_taxa', primaryKey: ['check_taxon_id'] },
  {
    table: 'place_reports',
    columns: [
      'place_report_id',
      'account_id',
      'place_id',
      'year',
      'data',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['place_report_id'],
  },
  { table: 'place_report_values', primaryKey: ['place_report_value_id'] },
  { table: 'messages', primaryKey: ['message_id'] },
  { table: 'user_messages', primaryKey: ['user_message_id'] },
  { table: 'place_users', primaryKey: ['place_user_id'] },
  {
    table: 'goals',
    columns: [
      'goal_id',
      'account_id',
      'subproject_id',
      'year',
      'name',
      'data',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['goal_id'],
  },
  { table: 'goal_reports', primaryKey: ['goal_report_id'] },
  { table: 'goal_report_values', primaryKey: ['goal_report_value_id'] },
  {
    table: 'subproject_reports',
    columns: [
      'subproject_report_id',
      'account_id',
      'subproject_id',
      'year',
      'data',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['subproject_report_id'],
  },
  {
    table: 'project_reports',
    columns: [
      'project_report_id',
      'account_id',
      'project_id',
      'year',
      'data',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['project_report_id'],
  },
  {
    table: 'files',
    columns: [
      'file_id',
      'account_id',
      'project_id',
      'subproject_id',
      'place_id',
      'action_id',
      'check_id',
      'name',
      'size',
      'data',
      'mimetype',
      'width',
      'height',
      'file',
      'preview',
      'url',
      'uuid',
      'preview_uuid',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['file_id'],
  },
  {
    table: 'persons',
    columns: [
      'person_id',
      'project_id',
      'account_id',
      'email',
      'data',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['person_id'],
  },
  {
    table: 'field_types',
    columns: [
      'field_type_id',
      'name',
      'sort',
      'comment',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['field_type_id'],
  },
  {
    table: 'widget_types',
    columns: [
      'widget_type_id',
      'name',
      'needs_list',
      'sort',
      'comment',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['widget_type_id'],
  },
  { table: 'widgets_for_fields', primaryKey: ['widget_for_field_id'] },
  {
    table: 'fields',
    columns: [
      'field_id',
      'project_id',
      'account_id',
      'table_name',
      'level',
      'field_type_id',
      'widget_type_id',
      'name',
      'field_label',
      'list_id',
      'preset',
      'obsolete',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['field_id'],
  },
  { table: 'field_sorts', primaryKey: ['field_sort_id'] },
  {
    table: 'occurrence_import_previous_operations',
    primaryKey: ['previous_import_operation'],
  },
  {
    table: 'occurrence_imports_geometry_methods',
    primaryKey: ['geometry_method'],
  },
  {
    table: 'occurrence_imports',
    columns: [
      'occurrence_import_id',
      'account_id',
      'subproject_id',
      'created_time',
      'inserted_count',
      'id_field',
      'geometry_method',
      'geojson_geometry_field',
      'x_coordinate_field',
      'y_coordinate_field',
      'crs',
      'label_creation',
      'name',
      'attribution',
      'previous_import',
      'previous_import_operation',
      'download_from_gbif',
      'gbif_filters',
      'gbif_download_key',
      'gbif_error',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['occurrence_import_id'],
  },
  { table: 'occurrences', primaryKey: ['occurrence_id'] },
  { table: 'wms_services', primaryKey: ['wms_service_id'] },
  {
    table: 'wms_service_layers',
    primaryKey: ['wms_service_layer_id'],
  },
  {
    table: 'wms_layers',
    primaryKey: ['wms_layer_id'],
  },
  {
    table: 'wfs_services',
    primaryKey: ['wfs_service_id'],
  },
  {
    table: 'wfs_service_layers',
    primaryKey: ['wfs_service_layer_id'],
  },
  {
    table: 'vector_layer_types',
    primaryKey: ['type'],
  },
  {
    table: 'vector_layer_own_tables',
    primaryKey: ['own_table'],
  },
  {
    table: 'vector_layers',
    primaryKey: ['vector_layer_id'],
  },
  {
    table: 'vector_layer_geoms',
    primaryKey: ['vector_layer_geom_id'],
  },
  {
    table: 'vector_layer_marker_types',
    primaryKey: ['marker_type'],
  },
  {
    table: 'vector_layer_line_caps',
    primaryKey: ['line_cap'],
  },
  {
    table: 'vector_layer_line_joins',
    primaryKey: ['line_join'],
  },
  {
    table: 'vector_layer_fill_rules',
    primaryKey: ['fill_rule'],
  },
  {
    table: 'vector_layer_displays',
    columns: [
      'vector_layer_display_id',
      'account_id',
      'vector_layer_id',
      'display_property_value',
      'marker_type',
      'circle_marker_radius',
      'marker_symbol',
      'marker_size',
      'stroke',
      'color',
      'weight',
      'line_cap',
      'line_join',
      'dash_array',
      'dash_offset',
      'fill',
      'fill_color',
      'fill_opacity_percent',
      'fill_rule',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['vector_layer_display_id'],
  },
  {
    table: 'layer_presentations',
    columns: [
      'layer_presentation_id',
      'account_id',
      'wms_layer_id',
      'vector_layer_id',
      'active',
      'opacity_percent',
      'transparent',
      'grayscale',
      'max_zoom',
      'min_zoom',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['layer_presentation_id'],
  },
  {
    table: 'chart_types',
    primaryKey: ['chart_type'],
  },
  {
    table: 'charts',
    columns: [
      'chart_id',
      'account_id',
      'project_id',
      'subproject_id',
      'place_id',
      'years_current',
      'years_previous',
      'years_specific',
      'years_last_x',
      'years_since',
      'years_until',
      'chart_type',
      'title',
      'subjects_stacked',
      'subjects_single',
      'percent',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['chart_id'],
  },
  {
    table: 'chart_subject_table_names',
    primaryKey: ['table_name'],
  },
  {
    table: 'chart_subject_table_levels',
    primaryKey: ['level'],
  },
  {
    table: 'chart_subject_value_sources',
    primaryKey: ['value_source'],
  },
  {
    table: 'chart_subject_types',
    primaryKey: ['type'],
  },
  {
    table: 'chart_subjects',
    primaryKey: ['chart_subject_id'],
  },
  {
    table: 'crs',
    columns: [
      'crs_id',
      'account_id',
      'code',
      'name',
      'proj4',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['crs_id'],
  },
  {
    table: 'project_crs',
    columns: [
      'project_crs_id',
      'crs_id',
      'project_id',
      'account_id',
      'code',
      'name',
      'proj4',
      'created_at',
      'updated_at',
      'updated_by',
    ],
    primaryKey: ['project_crs_id'],
  },
]

export const startSyncingSingly = async (db) => {
  console.log('Sync of projects from server to PGlite initiated')
  let syncs = []

  // wait for the other sync to end
  await new Promise((resolve) => setTimeout(resolve, 1000))
  while (store.get(syncingAtom)) {
    console.log('waiting for previous sync to finish...')
    await new Promise((resolve) => setTimeout(resolve, 500))
  }

  // loop through tablesSyncData to start syncing each table
  for (const tableData of tablesSyncData) {
    const table = tableData.table
    const columns = tableData.columns
    const primaryKey = tableData.primaryKey
    const isLastTableData =
      tableData.table === tablesSyncData[tablesSyncData.length - 1].table

    const tableSync = await db.electric.syncShapeToTable({
      shape: {
        url,
        params: { table },
      },
      liveSse: true,
      table,
      // only add columns if they are specified
      ...(columns ? { columns } : {}),
      primaryKey,
      key: `ps-sync-${table}`, // TODO: use user-specific key once auth is implemented
      shapeKey: `ps-sync-shape-${table}`,
      initialInsertMethod: 'csv',
      onInitialSync: () => {
        console.log(`initial sync done for table ${table}`)
        // setTimeout(() => window.location.reload(true), 1000)
        // if this is last tableData, run store.set(syncingAtom, false)
        if (isLastTableData) {
          store.set(syncingAtom, false)
          console.log(`all initial syncs done`)
        }
      },
      onError: (error) => console.error(`Syncer ${table}`, error),
    })

    syncs.push(tableSync)
  }

  return syncs
}
