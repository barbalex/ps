export default [
  {
    "statements": [
      "CREATE TABLE users (\n    user_id uuid NOT NULL,\n    email text,\n    label_replace_by_generated_column text,\n    CONSTRAINT users_pkey PRIMARY KEY (user_id)\n)",
      "CREATE INDEX users_email_idx ON public.users USING btree (email)",
      "CREATE TABLE accounts (\n    account_id uuid NOT NULL,\n    user_id uuid,\n    type text,\n    period_start date,\n    period_end date,\n    projects_label_by text,\n    label text,\n    CONSTRAINT accounts_pkey PRIMARY KEY (account_id),\n    CONSTRAINT accounts_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(user_id)\n)",
      "CREATE INDEX accounts_label_idx ON public.accounts USING btree (label)",
      "CREATE INDEX accounts_period_end_idx ON public.accounts USING btree (period_end)",
      "CREATE INDEX accounts_period_start_idx ON public.accounts USING btree (period_start)",
      "CREATE INDEX accounts_user_id_idx ON public.accounts USING btree (user_id)",
      "CREATE TYPE project_type AS ENUM (\n 'species',\n 'biotope'\n)",
      "CREATE TABLE projects (\n    project_id uuid NOT NULL,\n    account_id uuid,\n    name text,\n    label text,\n    type project_type,\n    subproject_name_singular text,\n    subproject_name_plural text,\n    subproject_order_by text,\n    places_label_by text,\n    places_order_by jsonb,\n    persons_label_by jsonb,\n    persons_order_by jsonb,\n    goals_label_by jsonb,\n    goal_reports_label_by text,\n    goal_reports_order_by text,\n    values_on_multiple_levels text,\n    multiple_action_values_on_same_level text,\n    multiple_check_values_on_same_level text,\n    data jsonb,\n    files_offline boolean,\n    files_active_projects boolean,\n    files_active_subprojects boolean,\n    files_active_places boolean,\n    files_active_actions boolean,\n    files_active_checks boolean,\n    map_presentation_crs text,\n    CONSTRAINT projects_pkey PRIMARY KEY (project_id),\n    CONSTRAINT projects_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX projects_account_id_idx ON public.projects USING btree (account_id)",
      "CREATE INDEX projects_label_idx ON public.projects USING btree (label)",
      "CREATE INDEX projects_name_idx ON public.projects USING btree (name)",
      "CREATE TABLE place_levels (\n    place_level_id uuid NOT NULL,\n    account_id uuid,\n    project_id uuid,\n    level integer,\n    name_singular text,\n    name_plural text,\n    name_short text,\n    reports boolean,\n    report_values boolean,\n    actions boolean,\n    action_values boolean,\n    action_reports boolean,\n    checks boolean,\n    check_values boolean,\n    check_taxa boolean,\n    occurrences boolean,\n    label_replace_by_generated_column text,\n    CONSTRAINT place_levels_pkey PRIMARY KEY (place_level_id),\n    CONSTRAINT place_levels_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT place_levels_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects(project_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX place_levels_account_id_idx ON public.place_levels USING btree (account_id)",
      "CREATE INDEX place_levels_level_idx ON public.place_levels USING btree (level)",
      "CREATE INDEX place_levels_name_singular_idx ON public.place_levels USING btree (name_singular)",
      "CREATE INDEX place_levels_project_id_idx ON public.place_levels USING btree (project_id)",
      "CREATE TABLE subprojects (\n    subproject_id uuid NOT NULL,\n    account_id uuid,\n    project_id uuid,\n    name text,\n    start_year integer,\n    end_year integer,\n    data jsonb,\n    label_replace_by_generated_column text,\n    CONSTRAINT subprojects_pkey PRIMARY KEY (subproject_id),\n    CONSTRAINT subprojects_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT subprojects_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects(project_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX subprojects_account_id_idx ON public.subprojects USING btree (account_id)",
      "CREATE INDEX subprojects_name_idx ON public.subprojects USING btree (name)",
      "CREATE INDEX subprojects_project_id_idx ON public.subprojects USING btree (project_id)",
      "CREATE INDEX subprojects_start_year_idx ON public.subprojects USING btree (start_year)",
      "CREATE TYPE user_role AS ENUM (\n 'manager',\n 'editor',\n 'reader'\n)",
      "CREATE TABLE project_users (\n    project_user_id uuid NOT NULL,\n    account_id uuid,\n    project_id uuid,\n    user_id uuid,\n    role user_role,\n    label text,\n    CONSTRAINT project_users_pkey PRIMARY KEY (project_user_id),\n    CONSTRAINT project_users_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT project_users_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects(project_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT project_users_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(user_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX project_users_account_id_idx ON public.project_users USING btree (account_id)",
      "CREATE INDEX project_users_label_idx ON public.project_users USING btree (label)",
      "CREATE INDEX project_users_project_id_idx ON public.project_users USING btree (project_id)",
      "CREATE INDEX project_users_user_id_idx ON public.project_users USING btree (user_id)",
      "CREATE TABLE subproject_users (\n    subproject_user_id uuid NOT NULL,\n    account_id uuid,\n    subproject_id uuid,\n    user_id uuid,\n    role user_role,\n    label text,\n    CONSTRAINT subproject_users_pkey PRIMARY KEY (subproject_user_id),\n    CONSTRAINT subproject_users_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT subproject_users_subproject_id_fkey FOREIGN KEY (subproject_id) REFERENCES subprojects(subproject_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT subproject_users_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(user_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX subproject_users_account_id_idx ON public.subproject_users USING btree (account_id)",
      "CREATE INDEX subproject_users_label_idx ON public.subproject_users USING btree (label)",
      "CREATE INDEX subproject_users_subproject_id_idx ON public.subproject_users USING btree (subproject_id)",
      "CREATE INDEX subproject_users_user_id_idx ON public.subproject_users USING btree (user_id)",
      "CREATE TYPE taxonomy_type AS ENUM (\n 'species',\n 'biotope'\n)",
      "CREATE TABLE taxonomies (\n    taxonomy_id uuid NOT NULL,\n    account_id uuid,\n    project_id uuid,\n    type taxonomy_type,\n    name text,\n    url text,\n    obsolete boolean,\n    data jsonb,\n    label_replace_by_generated_column text,\n    CONSTRAINT taxonomies_pkey PRIMARY KEY (taxonomy_id),\n    CONSTRAINT taxonomies_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT taxonomies_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects(project_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX taxonomies_account_id_idx ON public.taxonomies USING btree (account_id)",
      "CREATE INDEX taxonomies_name_idx ON public.taxonomies USING btree (name)",
      "CREATE INDEX taxonomies_project_id_idx ON public.taxonomies USING btree (project_id)",
      "CREATE INDEX taxonomies_type_idx ON public.taxonomies USING btree (type)",
      "CREATE TABLE taxa (\n    taxon_id uuid NOT NULL,\n    account_id uuid,\n    taxonomy_id uuid,\n    name text,\n    id_in_source text,\n    data jsonb,\n    url text,\n    label text,\n    CONSTRAINT taxa_pkey PRIMARY KEY (taxon_id),\n    CONSTRAINT taxa_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT taxa_taxonomy_id_fkey FOREIGN KEY (taxonomy_id) REFERENCES taxonomies(taxonomy_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX taxa_account_id_idx ON public.taxa USING btree (account_id)",
      "CREATE INDEX taxa_label_idx ON public.taxa USING btree (label)",
      "CREATE INDEX taxa_name_idx ON public.taxa USING btree (name)",
      "CREATE INDEX taxa_taxonomy_id_idx ON public.taxa USING btree (taxonomy_id)",
      "CREATE TABLE subproject_taxa (\n    subproject_taxon_id uuid NOT NULL,\n    account_id uuid,\n    subproject_id uuid,\n    taxon_id uuid,\n    label text,\n    CONSTRAINT subproject_taxa_pkey PRIMARY KEY (subproject_taxon_id),\n    CONSTRAINT subproject_taxa_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT subproject_taxa_subproject_id_fkey FOREIGN KEY (subproject_id) REFERENCES subprojects(subproject_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT subproject_taxa_taxon_id_fkey FOREIGN KEY (taxon_id) REFERENCES taxa(taxon_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX subproject_taxa_account_id_idx ON public.subproject_taxa USING btree (account_id)",
      "CREATE INDEX subproject_taxa_label_idx ON public.subproject_taxa USING btree (label)",
      "CREATE INDEX subproject_taxa_subproject_id_idx ON public.subproject_taxa USING btree (subproject_id)",
      "CREATE INDEX subproject_taxa_taxon_id_idx ON public.subproject_taxa USING btree (taxon_id)",
      "CREATE TABLE lists (\n    list_id uuid NOT NULL,\n    account_id uuid,\n    project_id uuid,\n    name text,\n    data jsonb,\n    obsolete boolean,\n    label_replace_by_generated_column text,\n    CONSTRAINT lists_pkey PRIMARY KEY (list_id),\n    CONSTRAINT lists_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT lists_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects(project_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX lists_account_id_idx ON public.lists USING btree (account_id);",
      "CREATE INDEX lists_name_idx ON public.lists USING btree (name);",
      "CREATE INDEX lists_project_id_idx ON public.lists USING btree (project_id);",
      "CREATE TABLE list_values (\n    list_value_id uuid NOT NULL,\n    account_id uuid,\n    list_id uuid,\n    value text,\n    obsolete boolean,\n    label_replace_by_generated_column text,\n    CONSTRAINT list_values_pkey PRIMARY KEY (list_value_id),\n    CONSTRAINT list_values_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT list_values_list_id_fkey FOREIGN KEY (list_id) REFERENCES lists(list_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX list_values_account_id_idx ON public.list_values USING btree (account_id);",
      "CREATE INDEX list_values_list_id_idx ON public.list_values USING btree (list_id);",
      "CREATE INDEX list_values_value_idx ON public.list_values USING btree (value);",
      "CREATE TYPE unit_type AS ENUM (\n 'integer',\n 'numeric',\n 'text'\n)",
      "CREATE TABLE units (\n    unit_id uuid NOT NULL,\n    account_id uuid,\n    project_id uuid,\n    use_for_action_values boolean,\n    use_for_action_report_values boolean,\n    use_for_check_values boolean,\n    use_for_place_report_values boolean,\n    use_for_goal_report_values boolean,\n    use_for_subproject_taxa boolean,\n    use_for_check_taxa boolean,\n    name text,\n    summable boolean,\n    sort integer,\n    type unit_type,\n    list_id uuid,\n    label_replace_by_generated_column text,\n    CONSTRAINT units_pkey PRIMARY KEY (unit_id),\n    CONSTRAINT units_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT units_list_id_fkey FOREIGN KEY (list_id) REFERENCES lists(list_id) ON UPDATE CASCADE,\n    CONSTRAINT units_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects(project_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX units_account_id_idx ON public.units USING btree (account_id)",
      "CREATE INDEX units_list_id_idx ON public.units USING btree (list_id)",
      "CREATE INDEX units_name_idx ON public.units USING btree (name)",
      "CREATE INDEX units_project_id_idx ON public.units USING btree (project_id)",
      "CREATE INDEX units_sort_idx ON public.units USING btree (sort)",
      "CREATE TABLE places (\n    place_id uuid NOT NULL,\n    account_id uuid,\n    subproject_id uuid,\n    parent_id uuid,\n    level integer,\n    since integer,\n    until integer,\n    data jsonb,\n    geometry jsonb,\n    bbox jsonb,\n    label text,\n    files_active_places boolean,\n    CONSTRAINT places_pkey PRIMARY KEY (place_id),\n    CONSTRAINT places_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT places_parent_id_fkey FOREIGN KEY (parent_id) REFERENCES places(place_id) ON UPDATE CASCADE,\n    CONSTRAINT places_subproject_id_fkey FOREIGN KEY (subproject_id) REFERENCES subprojects(subproject_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX places_account_id_idx ON public.places USING btree (account_id)",
      "CREATE INDEX places_label_idx ON public.places USING btree (label)",
      "CREATE INDEX places_level_idx ON public.places USING btree (level)",
      "CREATE INDEX places_parent_id_idx ON public.places USING btree (parent_id)",
      "CREATE INDEX places_subproject_id_idx ON public.places USING btree (subproject_id)",
      "CREATE TABLE actions (\n    action_id uuid NOT NULL,\n    account_id uuid,\n    place_id uuid,\n    date date,\n    data jsonb,\n    geometry jsonb,\n    bbox jsonb,\n    relevant_for_reports boolean,\n    label_replace_by_generated_column text,\n    CONSTRAINT actions_pkey PRIMARY KEY (action_id),\n    CONSTRAINT actions_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT actions_place_id_fkey FOREIGN KEY (place_id) REFERENCES places(place_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX actions_account_id_idx ON public.actions USING btree (account_id)",
      "CREATE INDEX actions_date_idx ON public.actions USING btree (date)",
      "CREATE INDEX actions_place_id_idx ON public.actions USING btree (place_id)",
      "CREATE TABLE action_values (\n    action_value_id uuid NOT NULL,\n    account_id uuid,\n    action_id uuid,\n    unit_id uuid,\n    value_integer integer,\n    value_numeric double precision,\n    value_text text,\n    label text,\n    CONSTRAINT action_values_pkey PRIMARY KEY (action_value_id),\n    CONSTRAINT action_values_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT action_values_action_id_fkey FOREIGN KEY (action_id) REFERENCES actions(action_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT action_values_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES units(unit_id) ON UPDATE CASCADE\n)",
      "CREATE INDEX action_values_account_id_idx ON public.action_values USING btree (account_id)",
      "CREATE INDEX action_values_action_id_idx ON public.action_values USING btree (action_id)",
      "CREATE INDEX action_values_label_idx ON public.action_values USING btree (label)",
      "CREATE INDEX action_values_unit_id_idx ON public.action_values USING btree (unit_id)",
      "CREATE INDEX action_values_value_integer_idx ON public.action_values USING btree (value_integer)",
      "CREATE INDEX action_values_value_numeric_idx ON public.action_values USING btree (value_numeric)",
      "CREATE INDEX action_values_value_text_idx ON public.action_values USING btree (value_text)",
      "CREATE TABLE action_reports (\n    action_report_id uuid NOT NULL,\n    account_id uuid,\n    action_id uuid,\n    year integer,\n    data jsonb,\n    label_replace_by_generated_column text,\n    CONSTRAINT action_reports_pkey PRIMARY KEY (action_report_id),\n    CONSTRAINT action_reports_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT action_reports_action_id_fkey FOREIGN KEY (action_id) REFERENCES actions(action_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX action_reports_account_id_idx ON public.action_reports USING btree (account_id)",
      "CREATE INDEX action_reports_action_id_idx ON public.action_reports USING btree (action_id)",
      "CREATE INDEX action_reports_year_idx ON public.action_reports USING btree (year)",
      "CREATE TABLE action_report_values (\n    action_report_value_id uuid NOT NULL,\n    account_id uuid,\n    action_report_id uuid,\n    unit_id uuid,\n    value_integer integer,\n    value_numeric double precision,\n    value_text text,\n    label text,\n    CONSTRAINT action_report_values_pkey PRIMARY KEY (action_report_value_id),\n    CONSTRAINT action_report_values_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT action_report_values_action_report_id_fkey FOREIGN KEY (action_report_id) REFERENCES action_reports(action_report_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT action_report_values_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES units(unit_id) ON UPDATE CASCADE\n)",
      "CREATE INDEX action_report_values_account_id_idx ON public.action_report_values USING btree (account_id)",
      "CREATE INDEX action_report_values_action_report_id_idx ON public.action_report_values USING btree (action_report_id)",
      "CREATE INDEX action_report_values_label_idx ON public.action_report_values USING btree (label)",
      "CREATE INDEX action_report_values_unit_id_idx ON public.action_report_values USING btree (unit_id)",
      "CREATE INDEX action_report_values_value_integer_idx ON public.action_report_values USING btree (value_integer)",
      "CREATE INDEX action_report_values_value_numeric_idx ON public.action_report_values USING btree (value_numeric)",
      "CREATE INDEX action_report_values_value_text_idx ON public.action_report_values USING btree (value_text)",
      "CREATE TABLE checks (\n    check_id uuid NOT NULL,\n    account_id uuid,\n    place_id uuid,\n    date date,\n    data jsonb,\n    geometry jsonb,\n    bbox jsonb,\n    relevant_for_reports boolean,\n    label_replace_by_generated_column text,\n    CONSTRAINT checks_pkey PRIMARY KEY (check_id),\n    CONSTRAINT checks_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT checks_place_id_fkey FOREIGN KEY (place_id) REFERENCES places(place_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX checks_account_id_idx ON public.checks USING btree (account_id)",
      "CREATE INDEX checks_date_idx ON public.checks USING btree (date)",
      "CREATE INDEX checks_place_id_idx ON public.checks USING btree (place_id)",
      "CREATE TABLE check_values (\n    check_value_id uuid NOT NULL,\n    account_id uuid,\n    check_id uuid,\n    unit_id uuid,\n    value_integer integer,\n    value_numeric double precision,\n    value_text text,\n    label text,\n    CONSTRAINT check_values_pkey PRIMARY KEY (check_value_id),\n    CONSTRAINT check_values_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT check_values_check_id_fkey FOREIGN KEY (check_id) REFERENCES checks(check_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT check_values_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES units(unit_id) ON UPDATE CASCADE\n)",
      "CREATE INDEX check_values_account_id_idx ON public.check_values USING btree (account_id)",
      "CREATE INDEX check_values_check_id_idx ON public.check_values USING btree (check_id)",
      "CREATE INDEX check_values_label_idx ON public.check_values USING btree (label)",
      "CREATE INDEX check_values_unit_id_idx ON public.check_values USING btree (unit_id)",
      "CREATE INDEX check_values_value_integer_idx ON public.check_values USING btree (value_integer)",
      "CREATE INDEX check_values_value_numeric_idx ON public.check_values USING btree (value_numeric)",
      "CREATE INDEX check_values_value_text_idx ON public.check_values USING btree (value_text)",
      "CREATE TABLE check_taxa (\n    check_taxon_id uuid NOT NULL,\n    account_id uuid,\n    check_id uuid,\n    taxon_id uuid,\n    unit_id uuid,\n    value_integer integer,\n    value_numeric double precision,\n    value_text text,\n    label text,\n    CONSTRAINT check_taxa_pkey PRIMARY KEY (check_taxon_id),\n    CONSTRAINT check_taxa_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT check_taxa_check_id_fkey FOREIGN KEY (check_id) REFERENCES checks(check_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT check_taxa_taxon_id_fkey FOREIGN KEY (taxon_id) REFERENCES taxa(taxon_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT check_taxa_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES units(unit_id) ON UPDATE CASCADE\n)",
      "CREATE INDEX check_taxa_account_id_idx ON public.check_taxa USING btree (account_id)",
      "CREATE INDEX check_taxa_check_id_idx ON public.check_taxa USING btree (check_id)",
      "CREATE INDEX check_taxa_label_idx ON public.check_taxa USING btree (label)",
      "CREATE INDEX check_taxa_taxon_id_idx ON public.check_taxa USING btree (taxon_id)",
      "CREATE INDEX check_taxa_unit_id_idx ON public.check_taxa USING btree (unit_id)",
      "CREATE INDEX check_taxa_value_integer_idx ON public.check_taxa USING btree (value_integer)",
      "CREATE INDEX check_taxa_value_numeric_idx ON public.check_taxa USING btree (value_numeric)",
      "CREATE INDEX check_taxa_value_text_idx ON public.check_taxa USING btree (value_text)",
      "CREATE TABLE place_reports (\n    place_report_id uuid NOT NULL,\n    account_id uuid,\n    place_id uuid,\n    year integer,\n    data jsonb,\n    label_replace_by_generated_column text,\n    CONSTRAINT place_reports_pkey PRIMARY KEY (place_report_id),\n    CONSTRAINT place_reports_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT place_reports_place_id_fkey FOREIGN KEY (place_id) REFERENCES places(place_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX place_reports_account_id_idx ON public.place_reports USING btree (account_id)",
      "CREATE INDEX place_reports_place_id_idx ON public.place_reports USING btree (place_id)",
      "CREATE INDEX place_reports_year_idx ON public.place_reports USING btree (year)",
      "CREATE TABLE place_report_values (\n    place_report_value_id uuid NOT NULL,\n    account_id uuid,\n    place_report_id uuid,\n    unit_id uuid,\n    value_integer integer,\n    value_numeric double precision,\n    value_text text,\n    label text,\n    CONSTRAINT place_report_values_pkey PRIMARY KEY (place_report_value_id),\n    CONSTRAINT place_report_values_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT place_report_values_place_report_id_fkey FOREIGN KEY (place_report_id) REFERENCES place_reports(place_report_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT place_report_values_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES units(unit_id) ON UPDATE CASCADE\n)",
      "CREATE INDEX place_report_values_account_id_idx ON public.place_report_values USING btree (account_id)",
      "CREATE INDEX place_report_values_label_idx ON public.place_report_values USING btree (label)",
      "CREATE INDEX place_report_values_place_report_id_idx ON public.place_report_values USING btree (place_report_id)",
      "CREATE INDEX place_report_values_unit_id_idx ON public.place_report_values USING btree (unit_id)",
      "CREATE INDEX place_report_values_value_integer_idx ON public.place_report_values USING btree (value_integer)",
      "CREATE INDEX place_report_values_value_numeric_idx ON public.place_report_values USING btree (value_numeric)",
      "CREATE INDEX place_report_values_value_text_idx ON public.place_report_values USING btree (value_text)",
      "CREATE TABLE messages (\n    message_id uuid NOT NULL,\n    label_replace_by_generated_column text,\n    date timestamp without time zone,\n    message text,\n    CONSTRAINT messages_pkey PRIMARY KEY (message_id)\n)",
      "CREATE INDEX messages_date_idx ON public.messages USING btree (date)",
      "CREATE TABLE user_messages (\n    user_message_id uuid NOT NULL,\n    account_id uuid,\n    user_id uuid,\n    message_id uuid,\n    label_replace_by_generated_column text,\n    read boolean,\n    CONSTRAINT user_messages_pkey PRIMARY KEY (user_message_id),\n    CONSTRAINT user_messages_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT user_messages_message_id_fkey FOREIGN KEY (message_id) REFERENCES messages(message_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT user_messages_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(user_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX user_messages_message_id_idx ON public.user_messages USING btree (message_id)",
      "CREATE INDEX user_messages_user_id_idx ON public.user_messages USING btree (user_id)",
      "CREATE TABLE place_users (\n    place_user_id uuid NOT NULL,\n    account_id uuid,\n    place_id uuid,\n    user_id uuid,\n    role user_role,\n    label text,\n    CONSTRAINT place_users_pkey PRIMARY KEY (place_user_id),\n    CONSTRAINT place_users_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT place_users_place_id_fkey FOREIGN KEY (place_id) REFERENCES places(place_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT place_users_user_id_fkey FOREIGN KEY (user_id) REFERENCES users(user_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX place_users_account_id_idx ON public.place_users USING btree (account_id)",
      "CREATE INDEX place_users_label_idx ON public.place_users USING btree (label)",
      "CREATE INDEX place_users_place_id_idx ON public.place_users USING btree (place_id)",
      "CREATE INDEX place_users_user_id_idx ON public.place_users USING btree (user_id)",
      "CREATE TABLE goals (\n    goal_id uuid NOT NULL,\n    account_id uuid,\n    subproject_id uuid,\n    year integer,\n    name text,\n    data jsonb,\n    label_replace_by_generated_column text,\n    CONSTRAINT goals_pkey PRIMARY KEY (goal_id),\n    CONSTRAINT goals_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT goals_subproject_id_fkey FOREIGN KEY (subproject_id) REFERENCES subprojects(subproject_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX goals_account_id_idx ON public.goals USING btree (account_id)",
      "CREATE INDEX goals_subproject_id_idx ON public.goals USING btree (subproject_id)",
      "CREATE INDEX goals_year_idx ON public.goals USING btree (year)",
      "CREATE TABLE goal_reports (\n    goal_report_id uuid NOT NULL,\n    account_id uuid,\n    goal_id uuid,\n    data jsonb,\n    label text,\n    CONSTRAINT goal_reports_pkey PRIMARY KEY (goal_report_id),\n    CONSTRAINT goal_reports_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT goal_reports_goal_id_fkey FOREIGN KEY (goal_id) REFERENCES goals(goal_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX goal_reports_account_id_idx ON public.goal_reports USING btree (account_id)",
      "CREATE INDEX goal_reports_goal_id_idx ON public.goal_reports USING btree (goal_id)",
      "CREATE INDEX goal_reports_label_idx ON public.goal_reports USING btree (label)",
      "CREATE TABLE goal_report_values (\n    goal_report_value_id uuid NOT NULL,\n    account_id uuid,\n    goal_report_id uuid,\n    unit_id uuid,\n    value_integer integer,\n    value_numeric double precision,\n    value_text text,\n    label text,\n    CONSTRAINT goal_report_values_pkey PRIMARY KEY (goal_report_value_id),\n    CONSTRAINT goal_report_values_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT goal_report_values_goal_report_id_fkey FOREIGN KEY (goal_report_id) REFERENCES goal_reports(goal_report_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT goal_report_values_unit_id_fkey FOREIGN KEY (unit_id) REFERENCES units(unit_id) ON UPDATE CASCADE\n)",
      "CREATE INDEX goal_report_values_account_id_idx ON public.goal_report_values USING btree (account_id)",
      "CREATE INDEX goal_report_values_goal_report_id_idx ON public.goal_report_values USING btree (goal_report_id)",
      "CREATE INDEX goal_report_values_label_idx ON public.goal_report_values USING btree (label)",
      "CREATE INDEX goal_report_values_unit_id_idx ON public.goal_report_values USING btree (unit_id)",
      "CREATE INDEX goal_report_values_value_integer_idx ON public.goal_report_values USING btree (value_integer)",
      "CREATE INDEX goal_report_values_value_numeric_idx ON public.goal_report_values USING btree (value_numeric)",
      "CREATE INDEX goal_report_values_value_text_idx ON public.goal_report_values USING btree (value_text)",
      "CREATE TABLE subproject_reports (\n    subproject_report_id uuid NOT NULL,\n    account_id uuid,\n    subproject_id uuid,\n    year integer,\n    data jsonb,\n    label_replace_by_generated_column text,\n    CONSTRAINT subproject_reports_pkey PRIMARY KEY (subproject_report_id),\n    CONSTRAINT subproject_reports_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT subproject_reports_subproject_id_fkey FOREIGN KEY (subproject_id) REFERENCES subprojects(subproject_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX subproject_reports_account_id_idx ON public.subproject_reports USING btree (account_id)",
      "CREATE INDEX subproject_reports_subproject_id_idx ON public.subproject_reports USING btree (subproject_id)",
      "CREATE INDEX subproject_reports_year_idx ON public.subproject_reports USING btree (year)",
      "CREATE TABLE project_reports (\n    project_report_id uuid NOT NULL,\n    account_id uuid,\n    project_id uuid,\n    year integer,\n    data jsonb,\n    label_replace_by_generated_column text,\n    CONSTRAINT project_reports_pkey PRIMARY KEY (project_report_id),\n    CONSTRAINT project_reports_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT project_reports_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects(project_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX project_reports_account_id_idx ON public.project_reports USING btree (account_id)",
      "CREATE INDEX project_reports_project_id_idx ON public.project_reports USING btree (project_id)",
      "CREATE INDEX project_reports_year_idx ON public.project_reports USING btree (year)",
      "CREATE TABLE files (\n    file_id uuid NOT NULL,\n    account_id uuid,\n    project_id uuid,\n    subproject_id uuid,\n    place_id uuid,\n    action_id uuid,\n    check_id uuid,\n    name text,\n    size bigint,\n    label_replace_by_generated_column text,\n    data jsonb,\n    mimetype text,\n    width integer,\n    height integer,\n    url text,\n    uuid uuid,\n    preview_uuid uuid,\n    CONSTRAINT files_pkey PRIMARY KEY (file_id),\n    CONSTRAINT files_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT files_action_id_fkey FOREIGN KEY (action_id) REFERENCES actions(action_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT files_check_id_fkey FOREIGN KEY (check_id) REFERENCES checks(check_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT files_place_id_fkey FOREIGN KEY (place_id) REFERENCES places(place_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT files_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects(project_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT files_subproject_id_fkey FOREIGN KEY (subproject_id) REFERENCES subprojects(subproject_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX files_account_id_idx ON public.files USING btree (account_id)",
      "CREATE INDEX files_action_id_idx ON public.files USING btree (action_id)",
      "CREATE INDEX files_check_id_idx ON public.files USING btree (check_id)",
      "CREATE INDEX files_name_idx ON public.files USING btree (name)",
      "CREATE INDEX files_place_id_idx ON public.files USING btree (place_id)",
      "CREATE INDEX files_project_id_idx ON public.files USING btree (project_id)",
      "CREATE INDEX files_subproject_id_idx ON public.files USING btree (subproject_id)",
      "CREATE TABLE persons (\n    person_id uuid NOT NULL,\n    project_id uuid,\n    account_id uuid,\n    email text,\n    data jsonb,\n    label_replace_by_generated_column text,\n    CONSTRAINT persons_pkey PRIMARY KEY (person_id),\n    CONSTRAINT persons_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT persons_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects(project_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX persons_account_id_idx ON public.persons USING btree (account_id)",
      "CREATE INDEX persons_email_idx ON public.persons USING btree (email)",
      "CREATE INDEX persons_project_id_idx ON public.persons USING btree (project_id)",
      "CREATE TABLE field_types (\n    field_type_id uuid NOT NULL,\n    name text,\n    sort smallint,\n    comment text,\n    label_replace_by_generated_column text,\n    CONSTRAINT field_types_pkey PRIMARY KEY (field_type_id)\n)",
      "CREATE INDEX field_types_name_idx ON public.field_types USING btree (name)",
      "CREATE INDEX field_types_sort_idx ON public.field_types USING btree (sort)",
      "CREATE TABLE widget_types (\n    widget_type_id uuid NOT NULL,\n    name text,\n    needs_list boolean,\n    sort smallint,\n    comment text,\n    label_replace_by_generated_column text,\n    CONSTRAINT widget_types_pkey PRIMARY KEY (widget_type_id)\n)",
      "CREATE INDEX widget_types_name_idx ON public.widget_types USING btree (name)",
      "CREATE INDEX widget_types_sort_idx ON public.widget_types USING btree (sort)",
      "CREATE TABLE widgets_for_fields (\n    widget_for_field_id uuid NOT NULL,\n    field_type_id uuid,\n    widget_type_id uuid,\n    label text,\n    CONSTRAINT widgets_for_fields_pkey PRIMARY KEY (widget_for_field_id),\n    CONSTRAINT widgets_for_fields_field_type_id_fkey FOREIGN KEY (field_type_id) REFERENCES field_types(field_type_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT widgets_for_fields_widget_type_id_fkey FOREIGN KEY (widget_type_id) REFERENCES widget_types(widget_type_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX widgets_for_fields_field_type_id_idx ON public.widgets_for_fields USING btree (field_type_id)",
      "CREATE INDEX widgets_for_fields_label_idx ON public.widgets_for_fields USING btree (label)",
      "CREATE INDEX widgets_for_fields_widget_type_id_idx ON public.widgets_for_fields USING btree (widget_type_id)",
      "CREATE TABLE fields (\n    field_id uuid NOT NULL,\n    project_id uuid,\n    account_id uuid,\n    table_name text,\n    level integer,\n    field_type_id uuid,\n    widget_type_id uuid,\n    name text,\n    field_label text,\n    list_id uuid,\n    preset text,\n    obsolete boolean,\n    sort_index integer,\n    label_replace_by_generated_column text,\n    CONSTRAINT fields_pkey PRIMARY KEY (field_id),\n    CONSTRAINT fields_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT fields_field_type_id_fkey FOREIGN KEY (field_type_id) REFERENCES field_types(field_type_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT fields_list_id_fkey FOREIGN KEY (list_id) REFERENCES lists(list_id) ON UPDATE CASCADE,\n    CONSTRAINT fields_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects(project_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT fields_widget_type_id_fkey FOREIGN KEY (widget_type_id) REFERENCES widget_types(widget_type_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX fields_account_id_idx ON public.fields USING btree (account_id)",
      "CREATE INDEX fields_field_type_id_idx ON public.fields USING btree (field_type_id)",
      "CREATE INDEX fields_level_idx ON public.fields USING btree (level)",
      "CREATE INDEX fields_list_id_idx ON public.fields USING btree (list_id)",
      "CREATE INDEX fields_name_idx ON public.fields USING btree (name)",
      "CREATE INDEX fields_project_id_idx ON public.fields USING btree (project_id)",
      "CREATE INDEX fields_sort_index_idx ON public.fields USING btree (sort_index)",
      "CREATE INDEX fields_table_name_idx ON public.fields USING btree (table_name)",
      "CREATE INDEX fields_widget_type_id_idx ON public.fields USING btree (widget_type_id)",
      "CREATE TYPE occurrence_imports_geometry_method_enum AS ENUM (\n 'coordinates',\n 'geojson'\n)",
      "CREATE TYPE occurrence_imports_previous_import_operation_enum AS ENUM (\n 'update_and_extend',\n 'replace'\n)",
      "CREATE TABLE occurrence_imports (\n    occurrence_import_id uuid NOT NULL,\n    account_id uuid,\n    subproject_id uuid,\n    created_time timestamp with time zone,\n    inserted_count integer,\n    id_field text,\n    geometry_method occurrence_imports_geometry_method_enum,\n    geojson_geometry_field text,\n    x_coordinate_field text,\n    y_coordinate_field text,\n    crs text,\n    label_creation jsonb,\n    name text,\n    attribution text,\n    previous_import uuid,\n    previous_import_operation occurrence_imports_previous_import_operation_enum,\n    download_from_gbif boolean,\n    gbif_filters jsonb,\n    gbif_download_key text,\n    gbif_error text,\n    label_replace_by_generated_column text,\n    CONSTRAINT occurrence_imports_pkey PRIMARY KEY (occurrence_import_id),\n    CONSTRAINT occurrence_imports_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT occurrence_imports_previous_import_fkey FOREIGN KEY (previous_import) REFERENCES occurrence_imports(occurrence_import_id) ON UPDATE CASCADE,\n    CONSTRAINT occurrence_imports_subproject_id_fkey FOREIGN KEY (subproject_id) REFERENCES subprojects(subproject_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX occurrence_imports_account_id_idx ON public.occurrence_imports USING btree (account_id)",
      "CREATE INDEX occurrence_imports_created_time_idx ON public.occurrence_imports USING btree (created_time)",
      "CREATE INDEX occurrence_imports_previous_import_idx ON public.occurrence_imports USING btree (previous_import)",
      "CREATE INDEX occurrence_imports_subproject_id_idx ON public.occurrence_imports USING btree (subproject_id)",
      "CREATE TABLE occurrences (\n    occurrence_id uuid NOT NULL,\n    account_id uuid,\n    occurrence_import_id uuid,\n    place_id uuid,\n    not_to_assign boolean,\n    comment text,\n    data jsonb,\n    id_in_source text,\n    geometry jsonb,\n    label text,\n    CONSTRAINT occurrences_pkey PRIMARY KEY (occurrence_id),\n    CONSTRAINT occurrences_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT occurrences_occurrence_import_id_fkey FOREIGN KEY (occurrence_import_id) REFERENCES occurrence_imports(occurrence_import_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT occurrences_place_id_fkey FOREIGN KEY (place_id) REFERENCES places(place_id) ON UPDATE CASCADE ON DELETE SET NULL\n)",
      "CREATE INDEX occurrences_account_id_idx ON public.occurrences USING btree (account_id)",
      "CREATE INDEX occurrences_label_idx ON public.occurrences USING btree (label)",
      "CREATE INDEX occurrences_occurrence_import_id_idx ON public.occurrences USING btree (occurrence_import_id)",
      "CREATE INDEX occurrences_place_id_idx ON public.occurrences USING btree (place_id)",
      "CREATE TABLE wms_layers (\n    wms_layer_id uuid NOT NULL,\n    account_id uuid,\n    project_id uuid NOT NULL,\n    wms_service_id uuid,\n    wms_service_layer_name text,\n    label text,\n    local_data_size integer,\n    local_data_bounds jsonb,\n    CONSTRAINT wms_layers_pkey PRIMARY KEY (wms_layer_id),\n    CONSTRAINT wms_layers_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT wms_layers_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects(project_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT wms_layers_wms_service_id_fkey FOREIGN KEY (wms_service_id) REFERENCES wms_services(wms_service_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX wms_layers_account_id_idx ON public.wms_layers USING btree (account_id)",
      "CREATE INDEX wms_layers_project_id_idx ON public.wms_layers USING btree (project_id)",
      "CREATE INDEX wms_layers_wms_service_layer_name_idx ON public.wms_layers USING btree (wms_service_layer_name)",
      "CREATE TYPE vector_layer_type_enum AS ENUM (\n 'wfs',\n 'upload',\n 'own'\n)",
      "CREATE TYPE vector_layer_own_table_enum AS ENUM (\n 'places',\n 'actions',\n 'checks',\n 'occurrences_assigned',\n 'occurrences_assigned_lines',\n 'occurrences_to_assess',\n 'occurrences_not_to_assign'\n)",
      "CREATE TABLE vector_layers (\n    vector_layer_id uuid NOT NULL,\n    account_id uuid,\n    label text,\n    project_id uuid NOT NULL,\n    type vector_layer_type_enum,\n    own_table vector_layer_own_table_enum,\n    own_table_level integer,\n    properties jsonb,\n    display_by_property text,\n    max_features integer,\n    wfs_service_id uuid,\n    wfs_service_layer_name text,\n    feature_count integer,\n    point_count integer,\n    line_count integer,\n    polygon_count integer,\n    CONSTRAINT vector_layers_pkey PRIMARY KEY (vector_layer_id),\n    CONSTRAINT vector_layers_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT vector_layers_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects(project_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT vector_layers_wfs_service_id_fkey FOREIGN KEY (wfs_service_id) REFERENCES wfs_services(wfs_service_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX vector_layers_account_id_idx ON public.vector_layers USING btree (account_id)",
      "CREATE INDEX vector_layers_label_idx ON public.vector_layers USING btree (label)",
      "CREATE INDEX vector_layers_own_table_idx ON public.vector_layers USING btree (own_table)",
      "CREATE INDEX vector_layers_own_table_level_idx ON public.vector_layers USING btree (own_table_level)",
      "CREATE INDEX vector_layers_project_id_idx ON public.vector_layers USING btree (project_id)",
      "CREATE INDEX vector_layers_type_idx ON public.vector_layers USING btree (type)",
      "CREATE TABLE vector_layer_geoms (\n    vector_layer_geom_id uuid NOT NULL,\n    account_id uuid,\n    vector_layer_id uuid,\n    geometry jsonb,\n    properties jsonb,\n    bbox_sw_lng real,\n    bbox_sw_lat real,\n    bbox_ne_lng real,\n    bbox_ne_lat real,\n    CONSTRAINT vector_layer_geoms_pkey PRIMARY KEY (vector_layer_geom_id),\n    CONSTRAINT vector_layer_geoms_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT vector_layer_geoms_vector_layer_id_fkey FOREIGN KEY (vector_layer_id) REFERENCES vector_layers(vector_layer_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX vector_layer_geoms_account_id_idx ON public.vector_layer_geoms USING btree (account_id)",
      "CREATE INDEX vector_layer_geoms_vector_layer_id_idx ON public.vector_layer_geoms USING btree (vector_layer_id)",
      "CREATE TYPE marker_type_enum AS ENUM (\n 'circle',\n 'marker'\n)",
      "CREATE TYPE line_cap_enum AS ENUM (\n 'butt',\n 'round',\n 'square'\n)",
      "CREATE TYPE fill_rule_enum AS ENUM (\n 'nonzero',\n 'evenodd'\n)",
      "CREATE TABLE vector_layer_displays (\n    vector_layer_display_id uuid NOT NULL,\n    account_id uuid,\n    vector_layer_id uuid,\n    display_property_value text,\n    marker_type marker_type_enum,\n    circle_marker_radius integer,\n    marker_symbol text,\n    marker_size integer,\n    stroke boolean,\n    color text,\n    weight integer,\n    line_cap line_cap_enum,\n    line_join text,\n    dash_array text,\n    dash_offset text,\n    fill boolean,\n    fill_color text,\n    fill_opacity_percent integer,\n    fill_rule fill_rule_enum,\n    label_replace_by_generated_column text,\n    CONSTRAINT vector_layer_displays_pkey PRIMARY KEY (vector_layer_display_id),\n    CONSTRAINT vector_layer_displays_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT vector_layer_displays_vector_layer_id_fkey FOREIGN KEY (vector_layer_id) REFERENCES vector_layers(vector_layer_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX vector_layer_displays_account_id_idx ON public.vector_layer_displays USING btree (account_id)",
      "CREATE INDEX vector_layer_displays_display_property_value_idx ON public.vector_layer_displays USING btree (display_property_value)",
      "CREATE INDEX vector_layer_displays_vector_layer_id_idx ON public.vector_layer_displays USING btree (vector_layer_id)",
      "CREATE TYPE notification_intent_enum AS ENUM (\n 'success',\n 'error',\n 'warning',\n 'info'\n)",
      "CREATE TABLE notifications (\n    notification_id uuid NOT NULL,\n    title text,\n    body text,\n    intent notification_intent_enum,\n    timeout integer,\n    paused boolean,\n    progress_percent integer,\n    CONSTRAINT notifications_pkey PRIMARY KEY (notification_id)\n)",
      "CREATE TYPE chart_type AS ENUM (\n 'Pie',\n 'Radar',\n 'Area'\n)",
      "CREATE TABLE charts (\n    chart_id uuid NOT NULL,\n    account_id uuid,\n    project_id uuid,\n    subproject_id uuid,\n    place_id uuid,\n    years_current boolean,\n    years_previous boolean,\n    years_specific integer,\n    years_last_x integer,\n    years_since integer,\n    years_until integer,\n    chart_type chart_type,\n    title text,\n    subjects_stacked boolean,\n    subjects_single boolean,\n    percent boolean,\n    label_replace_by_generated_column text,\n    CONSTRAINT charts_pkey PRIMARY KEY (chart_id),\n    CONSTRAINT charts_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT charts_place_id_fkey FOREIGN KEY (place_id) REFERENCES places(place_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT charts_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects(project_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT charts_subproject_id_fkey FOREIGN KEY (subproject_id) REFERENCES subprojects(subproject_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX charts_account_id_idx ON public.charts USING btree (account_id)",
      "CREATE INDEX charts_chart_id_idx ON public.charts USING btree (chart_id)",
      "CREATE INDEX charts_place_id_idx ON public.charts USING btree (place_id)",
      "CREATE INDEX charts_project_id_idx ON public.charts USING btree (project_id)",
      "CREATE INDEX charts_subproject_id_idx ON public.charts USING btree (subproject_id)",
      "CREATE TYPE chart_subject_table AS ENUM (\n 'subprojects',\n 'places',\n 'checks',\n 'check_values',\n 'actions',\n 'action_values'\n)",
      "CREATE TYPE chart_subject_value_source AS ENUM (\n 'count_rows',\n 'count_rows_by_distinct_field_values',\n 'sum_values_of_field'\n)",
      "CREATE TYPE chart_subject_type AS ENUM (\n 'linear',\n 'monotone'\n)",
      "CREATE TABLE chart_subjects (\n    chart_subject_id uuid NOT NULL,\n    account_id uuid,\n    chart_id uuid,\n    table_name chart_subject_table,\n    table_level integer,\n    table_filter jsonb,\n    value_source chart_subject_value_source,\n    value_field text,\n    value_unit uuid,\n    name text,\n    label_replace_by_generated_column text,\n    type chart_subject_type,\n    stroke text,\n    fill text,\n    fill_graded boolean,\n    connect_nulls boolean,\n    sort integer,\n    CONSTRAINT chart_subjects_pkey PRIMARY KEY (chart_subject_id),\n    CONSTRAINT chart_subjects_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT chart_subjects_chart_id_fkey FOREIGN KEY (chart_id) REFERENCES charts(chart_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT chart_subjects_value_unit_fkey FOREIGN KEY (value_unit) REFERENCES units(unit_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX chart_subjects_account_id_idx ON public.chart_subjects USING btree (account_id)",
      "CREATE INDEX chart_subjects_chart_id_idx ON public.chart_subjects USING btree (chart_id)",
      "CREATE INDEX chart_subjects_chart_subject_id_idx ON public.chart_subjects USING btree (chart_subject_id)",
      "CREATE INDEX chart_subjects_table_level_idx ON public.chart_subjects USING btree (table_level)",
      "CREATE INDEX chart_subjects_table_name_idx ON public.chart_subjects USING btree (table_name)",
      "CREATE INDEX chart_subjects_value_field_idx ON public.chart_subjects USING btree (value_field)",
      "CREATE INDEX chart_subjects_value_unit_idx ON public.chart_subjects USING btree (value_unit)",
      "CREATE TABLE crs (\n    crs_id uuid NOT NULL,\n    account_id uuid,\n    code text,\n    name text,\n    proj4 text,\n    label_replace_by_generated_column text,\n    CONSTRAINT crs_pkey PRIMARY KEY (crs_id),\n    CONSTRAINT crs_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX crs_account_id_idx ON public.crs USING btree (account_id)",
      "CREATE INDEX crs_code_idx ON public.crs USING btree (code)",
      "CREATE TABLE project_crs (\n    project_crs_id uuid NOT NULL,\n    crs_id uuid,\n    project_id uuid,\n    account_id uuid,\n    code text,\n    name text,\n    proj4 text,\n    label_replace_by_generated_column text,\n    CONSTRAINT project_crs_pkey PRIMARY KEY (project_crs_id),\n    CONSTRAINT project_crs_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT project_crs_crs_id_fkey FOREIGN KEY (crs_id) REFERENCES crs(crs_id) ON UPDATE CASCADE,\n    CONSTRAINT project_crs_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects(project_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX project_crs_account_id_idx ON public.project_crs USING btree (account_id)",
      "CREATE INDEX project_crs_code_idx ON public.project_crs USING btree (code)",
      "CREATE INDEX project_crs_project_id_idx ON public.project_crs USING btree (project_id)",
      "CREATE TABLE layer_presentations (\n    layer_presentation_id uuid NOT NULL,\n    account_id uuid,\n    wms_layer_id uuid,\n    vector_layer_id uuid,\n    active boolean,\n    opacity_percent integer,\n    transparent boolean,\n    grayscale boolean,\n    max_zoom integer,\n    min_zoom integer,\n    label_replace_by_generated_column text,\n    CONSTRAINT layer_presentations_pkey PRIMARY KEY (layer_presentation_id),\n    CONSTRAINT layer_presentations_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT layer_presentations_vector_layer_id_fkey FOREIGN KEY (vector_layer_id) REFERENCES vector_layers(vector_layer_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT layer_presentations_wms_layer_id_fkey FOREIGN KEY (wms_layer_id) REFERENCES wms_layers(wms_layer_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX layer_presentations_account_id_idx ON public.layer_presentations USING btree (account_id)",
      "CREATE INDEX layer_presentations_active_idx ON public.layer_presentations USING btree (active)",
      "CREATE INDEX layer_presentations_vector_layer_id_idx ON public.layer_presentations USING btree (vector_layer_id)",
      "CREATE INDEX layer_presentations_wms_layer_id_idx ON public.layer_presentations USING btree (wms_layer_id)",
      "CREATE TABLE wms_services (\n    wms_service_id uuid NOT NULL,\n    account_id uuid,\n    project_id uuid NOT NULL,\n    url text,\n    image_formats jsonb,\n    image_format text,\n    version text,\n    info_formats jsonb,\n    info_format text,\n    default_crs text,\n    CONSTRAINT wms_services_pkey PRIMARY KEY (wms_service_id),\n    CONSTRAINT wms_services_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT wms_services_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects(project_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX wms_services_account_id_idx ON public.wms_services USING btree (account_id)",
      "CREATE INDEX wms_services_project_id_idx ON public.wms_services USING btree (project_id)",
      "CREATE INDEX wms_services_url_idx ON public.wms_services USING btree (url)",
      "CREATE TABLE wms_service_layers (\n    wms_service_layer_id uuid NOT NULL,\n    account_id uuid,\n    wms_service_id uuid,\n    name text,\n    label text,\n    queryable boolean,\n    legend_url text,\n    legend_image bytea,\n    CONSTRAINT wms_service_layers_pkey PRIMARY KEY (wms_service_layer_id),\n    CONSTRAINT wms_service_layers_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT wms_service_layers_wms_service_id_fkey FOREIGN KEY (wms_service_id) REFERENCES wms_services(wms_service_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX wms_service_layers_wms_service_id_idx ON public.wms_service_layers USING btree (wms_service_id)",
      "CREATE TABLE wfs_services (\n    wfs_service_id uuid NOT NULL,\n    account_id uuid,\n    project_id uuid NOT NULL,\n    url text,\n    version text,\n    info_formats jsonb,\n    info_format text,\n    default_crs text,\n    CONSTRAINT wfs_services_pkey PRIMARY KEY (wfs_service_id),\n    CONSTRAINT wfs_services_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT wfs_services_project_id_fkey FOREIGN KEY (project_id) REFERENCES projects(project_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX wfs_services_account_id_idx ON public.wfs_services USING btree (account_id)",
      "CREATE INDEX wfs_services_project_id_idx ON public.wfs_services USING btree (project_id)",
      "CREATE INDEX wfs_services_url_idx ON public.wfs_services USING btree (url)",
      "CREATE TABLE wfs_service_layers (\n    wfs_service_layer_id uuid NOT NULL,\n    account_id uuid,\n    wfs_service_id uuid,\n    name text,\n    label text,\n    CONSTRAINT wfs_service_layers_pkey PRIMARY KEY (wfs_service_layer_id),\n    CONSTRAINT wfs_service_layers_account_id_fkey FOREIGN KEY (account_id) REFERENCES accounts(account_id) ON UPDATE CASCADE ON DELETE CASCADE,\n    CONSTRAINT wfs_service_layers_wfs_service_id_fkey FOREIGN KEY (wfs_service_id) REFERENCES wfs_services(wfs_service_id) ON UPDATE CASCADE ON DELETE CASCADE\n)",
      "CREATE INDEX wfs_service_layers_wfs_service_id_idx ON public.wfs_service_layers USING btree (wfs_service_id)",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'users', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_users_primarykey ON \"public\".\"users\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_users_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"user_id\" IS DISTINCT FROM NEW.\"user_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column user_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_users_primarykey\n  BEFORE UPDATE ON \"public\".\"users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_users_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_users_into_oplog ON \"public\".\"users\";",
      "    CREATE OR REPLACE FUNCTION insert_public_users_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'users';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'users',\n            'INSERT',\n            json_strip_nulls(json_build_object('user_id', new.\"user_id\")),\n            jsonb_build_object('email', new.\"email\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'user_id', new.\"user_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_users_into_oplog\n  AFTER INSERT ON \"public\".\"users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_users_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_users_into_oplog ON \"public\".\"users\";",
      "    CREATE OR REPLACE FUNCTION update_public_users_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'users';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'users',\n            'UPDATE',\n            json_strip_nulls(json_build_object('user_id', new.\"user_id\")),\n            jsonb_build_object('email', new.\"email\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'user_id', new.\"user_id\"),\n            jsonb_build_object('email', old.\"email\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'user_id', old.\"user_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_users_into_oplog\n  AFTER UPDATE ON \"public\".\"users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_users_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_users_into_oplog ON \"public\".\"users\";",
      "    CREATE OR REPLACE FUNCTION delete_public_users_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'users';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'users',\n            'DELETE',\n            json_strip_nulls(json_build_object('user_id', old.\"user_id\")),\n            NULL,\n            jsonb_build_object('email', old.\"email\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'user_id', old.\"user_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_users_into_oplog\n  AFTER DELETE ON \"public\".\"users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_users_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'accounts', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_accounts_primarykey ON \"public\".\"accounts\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_accounts_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"account_id\" IS DISTINCT FROM NEW.\"account_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column account_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_accounts_primarykey\n  BEFORE UPDATE ON \"public\".\"accounts\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_accounts_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_accounts_into_oplog ON \"public\".\"accounts\";",
      "    CREATE OR REPLACE FUNCTION insert_public_accounts_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'accounts';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'accounts',\n            'INSERT',\n            json_strip_nulls(json_build_object('account_id', new.\"account_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label', new.\"label\", 'period_end', new.\"period_end\", 'period_start', new.\"period_start\", 'projects_label_by', new.\"projects_label_by\", 'type', new.\"type\", 'user_id', new.\"user_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_accounts_into_oplog\n  AFTER INSERT ON \"public\".\"accounts\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_accounts_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_accounts_into_oplog ON \"public\".\"accounts\";",
      "    CREATE OR REPLACE FUNCTION update_public_accounts_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'accounts';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'accounts',\n            'UPDATE',\n            json_strip_nulls(json_build_object('account_id', new.\"account_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label', new.\"label\", 'period_end', new.\"period_end\", 'period_start', new.\"period_start\", 'projects_label_by', new.\"projects_label_by\", 'type', new.\"type\", 'user_id', new.\"user_id\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'label', old.\"label\", 'period_end', old.\"period_end\", 'period_start', old.\"period_start\", 'projects_label_by', old.\"projects_label_by\", 'type', old.\"type\", 'user_id', old.\"user_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_accounts_into_oplog\n  AFTER UPDATE ON \"public\".\"accounts\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_accounts_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_accounts_into_oplog ON \"public\".\"accounts\";",
      "    CREATE OR REPLACE FUNCTION delete_public_accounts_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'accounts';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'accounts',\n            'DELETE',\n            json_strip_nulls(json_build_object('account_id', old.\"account_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'label', old.\"label\", 'period_end', old.\"period_end\", 'period_start', old.\"period_start\", 'projects_label_by', old.\"projects_label_by\", 'type', old.\"type\", 'user_id', old.\"user_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_accounts_into_oplog\n  AFTER DELETE ON \"public\".\"accounts\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_accounts_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_accounts_user_id_into_oplog ON \"public\".\"accounts\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_accounts_user_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'accounts';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'users',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('user_id', \"user_id\"))),\n            jsonb_build_object('user_id', \"user_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"users\"\n          WHERE \"user_id\" = NEW.\"user_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_accounts_user_id_into_oplog\n  AFTER INSERT ON \"public\".\"accounts\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_accounts_user_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_accounts_user_id_into_oplog ON \"public\".\"accounts\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_accounts_user_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'accounts';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'users',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('user_id', \"user_id\"))),\n            jsonb_build_object('user_id', \"user_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"users\"\n          WHERE \"user_id\" = NEW.\"user_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_accounts_user_id_into_oplog\n  AFTER UPDATE ON \"public\".\"accounts\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_accounts_user_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'projects', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_projects_primarykey ON \"public\".\"projects\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_projects_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"project_id\" IS DISTINCT FROM NEW.\"project_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column project_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_projects_primarykey\n  BEFORE UPDATE ON \"public\".\"projects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_projects_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_projects_into_oplog ON \"public\".\"projects\";",
      "    CREATE OR REPLACE FUNCTION insert_public_projects_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'projects';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'projects',\n            'INSERT',\n            json_strip_nulls(json_build_object('project_id', new.\"project_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'files_active_actions', new.\"files_active_actions\", 'files_active_checks', new.\"files_active_checks\", 'files_active_places', new.\"files_active_places\", 'files_active_projects', new.\"files_active_projects\", 'files_active_subprojects', new.\"files_active_subprojects\", 'files_offline', new.\"files_offline\", 'goal_reports_label_by', new.\"goal_reports_label_by\", 'goal_reports_order_by', new.\"goal_reports_order_by\", 'goals_label_by', new.\"goals_label_by\", 'label', new.\"label\", 'map_presentation_crs', new.\"map_presentation_crs\", 'multiple_action_values_on_same_level', new.\"multiple_action_values_on_same_level\", 'multiple_check_values_on_same_level', new.\"multiple_check_values_on_same_level\", 'name', new.\"name\", 'persons_label_by', new.\"persons_label_by\", 'persons_order_by', new.\"persons_order_by\", 'places_label_by', new.\"places_label_by\", 'places_order_by', new.\"places_order_by\", 'project_id', new.\"project_id\", 'subproject_name_plural', new.\"subproject_name_plural\", 'subproject_name_singular', new.\"subproject_name_singular\", 'subproject_order_by', new.\"subproject_order_by\", 'type', new.\"type\", 'values_on_multiple_levels', new.\"values_on_multiple_levels\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_projects_into_oplog\n  AFTER INSERT ON \"public\".\"projects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_projects_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_projects_into_oplog ON \"public\".\"projects\";",
      "    CREATE OR REPLACE FUNCTION update_public_projects_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'projects';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'projects',\n            'UPDATE',\n            json_strip_nulls(json_build_object('project_id', new.\"project_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'files_active_actions', new.\"files_active_actions\", 'files_active_checks', new.\"files_active_checks\", 'files_active_places', new.\"files_active_places\", 'files_active_projects', new.\"files_active_projects\", 'files_active_subprojects', new.\"files_active_subprojects\", 'files_offline', new.\"files_offline\", 'goal_reports_label_by', new.\"goal_reports_label_by\", 'goal_reports_order_by', new.\"goal_reports_order_by\", 'goals_label_by', new.\"goals_label_by\", 'label', new.\"label\", 'map_presentation_crs', new.\"map_presentation_crs\", 'multiple_action_values_on_same_level', new.\"multiple_action_values_on_same_level\", 'multiple_check_values_on_same_level', new.\"multiple_check_values_on_same_level\", 'name', new.\"name\", 'persons_label_by', new.\"persons_label_by\", 'persons_order_by', new.\"persons_order_by\", 'places_label_by', new.\"places_label_by\", 'places_order_by', new.\"places_order_by\", 'project_id', new.\"project_id\", 'subproject_name_plural', new.\"subproject_name_plural\", 'subproject_name_singular', new.\"subproject_name_singular\", 'subproject_order_by', new.\"subproject_order_by\", 'type', new.\"type\", 'values_on_multiple_levels', new.\"values_on_multiple_levels\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'files_active_actions', old.\"files_active_actions\", 'files_active_checks', old.\"files_active_checks\", 'files_active_places', old.\"files_active_places\", 'files_active_projects', old.\"files_active_projects\", 'files_active_subprojects', old.\"files_active_subprojects\", 'files_offline', old.\"files_offline\", 'goal_reports_label_by', old.\"goal_reports_label_by\", 'goal_reports_order_by', old.\"goal_reports_order_by\", 'goals_label_by', old.\"goals_label_by\", 'label', old.\"label\", 'map_presentation_crs', old.\"map_presentation_crs\", 'multiple_action_values_on_same_level', old.\"multiple_action_values_on_same_level\", 'multiple_check_values_on_same_level', old.\"multiple_check_values_on_same_level\", 'name', old.\"name\", 'persons_label_by', old.\"persons_label_by\", 'persons_order_by', old.\"persons_order_by\", 'places_label_by', old.\"places_label_by\", 'places_order_by', old.\"places_order_by\", 'project_id', old.\"project_id\", 'subproject_name_plural', old.\"subproject_name_plural\", 'subproject_name_singular', old.\"subproject_name_singular\", 'subproject_order_by', old.\"subproject_order_by\", 'type', old.\"type\", 'values_on_multiple_levels', old.\"values_on_multiple_levels\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_projects_into_oplog\n  AFTER UPDATE ON \"public\".\"projects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_projects_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_projects_into_oplog ON \"public\".\"projects\";",
      "    CREATE OR REPLACE FUNCTION delete_public_projects_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'projects';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'projects',\n            'DELETE',\n            json_strip_nulls(json_build_object('project_id', old.\"project_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'files_active_actions', old.\"files_active_actions\", 'files_active_checks', old.\"files_active_checks\", 'files_active_places', old.\"files_active_places\", 'files_active_projects', old.\"files_active_projects\", 'files_active_subprojects', old.\"files_active_subprojects\", 'files_offline', old.\"files_offline\", 'goal_reports_label_by', old.\"goal_reports_label_by\", 'goal_reports_order_by', old.\"goal_reports_order_by\", 'goals_label_by', old.\"goals_label_by\", 'label', old.\"label\", 'map_presentation_crs', old.\"map_presentation_crs\", 'multiple_action_values_on_same_level', old.\"multiple_action_values_on_same_level\", 'multiple_check_values_on_same_level', old.\"multiple_check_values_on_same_level\", 'name', old.\"name\", 'persons_label_by', old.\"persons_label_by\", 'persons_order_by', old.\"persons_order_by\", 'places_label_by', old.\"places_label_by\", 'places_order_by', old.\"places_order_by\", 'project_id', old.\"project_id\", 'subproject_name_plural', old.\"subproject_name_plural\", 'subproject_name_singular', old.\"subproject_name_singular\", 'subproject_order_by', old.\"subproject_order_by\", 'type', old.\"type\", 'values_on_multiple_levels', old.\"values_on_multiple_levels\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_projects_into_oplog\n  AFTER DELETE ON \"public\".\"projects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_projects_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_projects_account_id_into_oplog ON \"public\".\"projects\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_projects_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'projects';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_projects_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"projects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_projects_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_projects_account_id_into_oplog ON \"public\".\"projects\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_projects_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'projects';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_projects_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"projects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_projects_account_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'place_levels', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_place_levels_primarykey ON \"public\".\"place_levels\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_place_levels_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"place_level_id\" IS DISTINCT FROM NEW.\"place_level_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column place_level_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_place_levels_primarykey\n  BEFORE UPDATE ON \"public\".\"place_levels\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_place_levels_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_place_levels_into_oplog ON \"public\".\"place_levels\";",
      "    CREATE OR REPLACE FUNCTION insert_public_place_levels_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_levels';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'place_levels',\n            'INSERT',\n            json_strip_nulls(json_build_object('place_level_id', new.\"place_level_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'action_reports', new.\"action_reports\", 'action_values', new.\"action_values\", 'actions', new.\"actions\", 'check_taxa', new.\"check_taxa\", 'check_values', new.\"check_values\", 'checks', new.\"checks\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'level', new.\"level\", 'name_plural', new.\"name_plural\", 'name_short', new.\"name_short\", 'name_singular', new.\"name_singular\", 'occurrences', new.\"occurrences\", 'place_level_id', new.\"place_level_id\", 'project_id', new.\"project_id\", 'report_values', new.\"report_values\", 'reports', new.\"reports\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_place_levels_into_oplog\n  AFTER INSERT ON \"public\".\"place_levels\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_place_levels_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_place_levels_into_oplog ON \"public\".\"place_levels\";",
      "    CREATE OR REPLACE FUNCTION update_public_place_levels_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_levels';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'place_levels',\n            'UPDATE',\n            json_strip_nulls(json_build_object('place_level_id', new.\"place_level_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'action_reports', new.\"action_reports\", 'action_values', new.\"action_values\", 'actions', new.\"actions\", 'check_taxa', new.\"check_taxa\", 'check_values', new.\"check_values\", 'checks', new.\"checks\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'level', new.\"level\", 'name_plural', new.\"name_plural\", 'name_short', new.\"name_short\", 'name_singular', new.\"name_singular\", 'occurrences', new.\"occurrences\", 'place_level_id', new.\"place_level_id\", 'project_id', new.\"project_id\", 'report_values', new.\"report_values\", 'reports', new.\"reports\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'action_reports', old.\"action_reports\", 'action_values', old.\"action_values\", 'actions', old.\"actions\", 'check_taxa', old.\"check_taxa\", 'check_values', old.\"check_values\", 'checks', old.\"checks\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'level', old.\"level\", 'name_plural', old.\"name_plural\", 'name_short', old.\"name_short\", 'name_singular', old.\"name_singular\", 'occurrences', old.\"occurrences\", 'place_level_id', old.\"place_level_id\", 'project_id', old.\"project_id\", 'report_values', old.\"report_values\", 'reports', old.\"reports\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_place_levels_into_oplog\n  AFTER UPDATE ON \"public\".\"place_levels\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_place_levels_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_place_levels_into_oplog ON \"public\".\"place_levels\";",
      "    CREATE OR REPLACE FUNCTION delete_public_place_levels_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_levels';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'place_levels',\n            'DELETE',\n            json_strip_nulls(json_build_object('place_level_id', old.\"place_level_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'action_reports', old.\"action_reports\", 'action_values', old.\"action_values\", 'actions', old.\"actions\", 'check_taxa', old.\"check_taxa\", 'check_values', old.\"check_values\", 'checks', old.\"checks\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'level', old.\"level\", 'name_plural', old.\"name_plural\", 'name_short', old.\"name_short\", 'name_singular', old.\"name_singular\", 'occurrences', old.\"occurrences\", 'place_level_id', old.\"place_level_id\", 'project_id', old.\"project_id\", 'report_values', old.\"report_values\", 'reports', old.\"reports\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_place_levels_into_oplog\n  AFTER DELETE ON \"public\".\"place_levels\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_place_levels_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_place_levels_account_id_into_oplog ON \"public\".\"place_levels\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_place_levels_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_levels';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_place_levels_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"place_levels\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_place_levels_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_place_levels_account_id_into_oplog ON \"public\".\"place_levels\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_place_levels_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_levels';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_place_levels_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"place_levels\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_place_levels_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_place_levels_project_id_into_oplog ON \"public\".\"place_levels\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_place_levels_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_levels';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_place_levels_project_id_into_oplog\n  AFTER INSERT ON \"public\".\"place_levels\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_place_levels_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_place_levels_project_id_into_oplog ON \"public\".\"place_levels\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_place_levels_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_levels';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_place_levels_project_id_into_oplog\n  AFTER UPDATE ON \"public\".\"place_levels\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_place_levels_project_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'subprojects', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_subprojects_primarykey ON \"public\".\"subprojects\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_subprojects_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"subproject_id\" IS DISTINCT FROM NEW.\"subproject_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column subproject_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_subprojects_primarykey\n  BEFORE UPDATE ON \"public\".\"subprojects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_subprojects_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_subprojects_into_oplog ON \"public\".\"subprojects\";",
      "    CREATE OR REPLACE FUNCTION insert_public_subprojects_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subprojects';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'subprojects',\n            'INSERT',\n            json_strip_nulls(json_build_object('subproject_id', new.\"subproject_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'end_year', new.\"end_year\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'name', new.\"name\", 'project_id', new.\"project_id\", 'start_year', new.\"start_year\", 'subproject_id', new.\"subproject_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_subprojects_into_oplog\n  AFTER INSERT ON \"public\".\"subprojects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_subprojects_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_subprojects_into_oplog ON \"public\".\"subprojects\";",
      "    CREATE OR REPLACE FUNCTION update_public_subprojects_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subprojects';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'subprojects',\n            'UPDATE',\n            json_strip_nulls(json_build_object('subproject_id', new.\"subproject_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'end_year', new.\"end_year\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'name', new.\"name\", 'project_id', new.\"project_id\", 'start_year', new.\"start_year\", 'subproject_id', new.\"subproject_id\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'end_year', old.\"end_year\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'name', old.\"name\", 'project_id', old.\"project_id\", 'start_year', old.\"start_year\", 'subproject_id', old.\"subproject_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_subprojects_into_oplog\n  AFTER UPDATE ON \"public\".\"subprojects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_subprojects_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_subprojects_into_oplog ON \"public\".\"subprojects\";",
      "    CREATE OR REPLACE FUNCTION delete_public_subprojects_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subprojects';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'subprojects',\n            'DELETE',\n            json_strip_nulls(json_build_object('subproject_id', old.\"subproject_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'end_year', old.\"end_year\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'name', old.\"name\", 'project_id', old.\"project_id\", 'start_year', old.\"start_year\", 'subproject_id', old.\"subproject_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_subprojects_into_oplog\n  AFTER DELETE ON \"public\".\"subprojects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_subprojects_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_subprojects_account_id_into_oplog ON \"public\".\"subprojects\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_subprojects_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subprojects';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_subprojects_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"subprojects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_subprojects_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_subprojects_account_id_into_oplog ON \"public\".\"subprojects\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_subprojects_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subprojects';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_subprojects_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"subprojects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_subprojects_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_subprojects_project_id_into_oplog ON \"public\".\"subprojects\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_subprojects_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subprojects';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_subprojects_project_id_into_oplog\n  AFTER INSERT ON \"public\".\"subprojects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_subprojects_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_subprojects_project_id_into_oplog ON \"public\".\"subprojects\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_subprojects_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subprojects';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_subprojects_project_id_into_oplog\n  AFTER UPDATE ON \"public\".\"subprojects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_subprojects_project_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'project_users', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_project_users_primarykey ON \"public\".\"project_users\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_project_users_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"project_user_id\" IS DISTINCT FROM NEW.\"project_user_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column project_user_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_project_users_primarykey\n  BEFORE UPDATE ON \"public\".\"project_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_project_users_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_project_users_into_oplog ON \"public\".\"project_users\";",
      "    CREATE OR REPLACE FUNCTION insert_public_project_users_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_users';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'project_users',\n            'INSERT',\n            json_strip_nulls(json_build_object('project_user_id', new.\"project_user_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label', new.\"label\", 'project_id', new.\"project_id\", 'project_user_id', new.\"project_user_id\", 'role', new.\"role\", 'user_id', new.\"user_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_project_users_into_oplog\n  AFTER INSERT ON \"public\".\"project_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_project_users_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_project_users_into_oplog ON \"public\".\"project_users\";",
      "    CREATE OR REPLACE FUNCTION update_public_project_users_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_users';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'project_users',\n            'UPDATE',\n            json_strip_nulls(json_build_object('project_user_id', new.\"project_user_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label', new.\"label\", 'project_id', new.\"project_id\", 'project_user_id', new.\"project_user_id\", 'role', new.\"role\", 'user_id', new.\"user_id\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'label', old.\"label\", 'project_id', old.\"project_id\", 'project_user_id', old.\"project_user_id\", 'role', old.\"role\", 'user_id', old.\"user_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_project_users_into_oplog\n  AFTER UPDATE ON \"public\".\"project_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_project_users_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_project_users_into_oplog ON \"public\".\"project_users\";",
      "    CREATE OR REPLACE FUNCTION delete_public_project_users_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_users';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'project_users',\n            'DELETE',\n            json_strip_nulls(json_build_object('project_user_id', old.\"project_user_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'label', old.\"label\", 'project_id', old.\"project_id\", 'project_user_id', old.\"project_user_id\", 'role', old.\"role\", 'user_id', old.\"user_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_project_users_into_oplog\n  AFTER DELETE ON \"public\".\"project_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_project_users_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_project_users_account_id_into_oplog ON \"public\".\"project_users\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_project_users_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_users';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_project_users_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"project_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_project_users_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_project_users_account_id_into_oplog ON \"public\".\"project_users\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_project_users_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_users';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_project_users_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"project_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_project_users_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_project_users_project_id_into_oplog ON \"public\".\"project_users\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_project_users_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_users';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_project_users_project_id_into_oplog\n  AFTER INSERT ON \"public\".\"project_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_project_users_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_project_users_project_id_into_oplog ON \"public\".\"project_users\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_project_users_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_users';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_project_users_project_id_into_oplog\n  AFTER UPDATE ON \"public\".\"project_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_project_users_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_project_users_user_id_into_oplog ON \"public\".\"project_users\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_project_users_user_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_users';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'users',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('user_id', \"user_id\"))),\n            jsonb_build_object('user_id', \"user_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"users\"\n          WHERE \"user_id\" = NEW.\"user_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_project_users_user_id_into_oplog\n  AFTER INSERT ON \"public\".\"project_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_project_users_user_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_project_users_user_id_into_oplog ON \"public\".\"project_users\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_project_users_user_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_users';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'users',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('user_id', \"user_id\"))),\n            jsonb_build_object('user_id', \"user_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"users\"\n          WHERE \"user_id\" = NEW.\"user_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_project_users_user_id_into_oplog\n  AFTER UPDATE ON \"public\".\"project_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_project_users_user_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'subproject_users', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_subproject_users_primarykey ON \"public\".\"subproject_users\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_subproject_users_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"subproject_user_id\" IS DISTINCT FROM NEW.\"subproject_user_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column subproject_user_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_subproject_users_primarykey\n  BEFORE UPDATE ON \"public\".\"subproject_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_subproject_users_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_subproject_users_into_oplog ON \"public\".\"subproject_users\";",
      "    CREATE OR REPLACE FUNCTION insert_public_subproject_users_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_users';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'subproject_users',\n            'INSERT',\n            json_strip_nulls(json_build_object('subproject_user_id', new.\"subproject_user_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label', new.\"label\", 'role', new.\"role\", 'subproject_id', new.\"subproject_id\", 'subproject_user_id', new.\"subproject_user_id\", 'user_id', new.\"user_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_subproject_users_into_oplog\n  AFTER INSERT ON \"public\".\"subproject_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_subproject_users_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_subproject_users_into_oplog ON \"public\".\"subproject_users\";",
      "    CREATE OR REPLACE FUNCTION update_public_subproject_users_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_users';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'subproject_users',\n            'UPDATE',\n            json_strip_nulls(json_build_object('subproject_user_id', new.\"subproject_user_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label', new.\"label\", 'role', new.\"role\", 'subproject_id', new.\"subproject_id\", 'subproject_user_id', new.\"subproject_user_id\", 'user_id', new.\"user_id\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'label', old.\"label\", 'role', old.\"role\", 'subproject_id', old.\"subproject_id\", 'subproject_user_id', old.\"subproject_user_id\", 'user_id', old.\"user_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_subproject_users_into_oplog\n  AFTER UPDATE ON \"public\".\"subproject_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_subproject_users_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_subproject_users_into_oplog ON \"public\".\"subproject_users\";",
      "    CREATE OR REPLACE FUNCTION delete_public_subproject_users_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_users';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'subproject_users',\n            'DELETE',\n            json_strip_nulls(json_build_object('subproject_user_id', old.\"subproject_user_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'label', old.\"label\", 'role', old.\"role\", 'subproject_id', old.\"subproject_id\", 'subproject_user_id', old.\"subproject_user_id\", 'user_id', old.\"user_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_subproject_users_into_oplog\n  AFTER DELETE ON \"public\".\"subproject_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_subproject_users_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_subproject_users_account_id_into_oplog ON \"public\".\"subproject_users\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_subproject_users_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_users';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_subproject_users_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"subproject_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_subproject_users_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_subproject_users_account_id_into_oplog ON \"public\".\"subproject_users\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_subproject_users_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_users';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_subproject_users_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"subproject_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_subproject_users_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_subproject_users_subproject_id_into_oplog ON \"public\".\"subproject_users\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_subproject_users_subproject_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_users';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'subprojects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('subproject_id', \"subproject_id\"))),\n            jsonb_build_object('subproject_id', \"subproject_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"subprojects\"\n          WHERE \"subproject_id\" = NEW.\"subproject_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_subproject_users_subproject_id_into_oplog\n  AFTER INSERT ON \"public\".\"subproject_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_subproject_users_subproject_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_subproject_users_subproject_id_into_oplog ON \"public\".\"subproject_users\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_subproject_users_subproject_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_users';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'subprojects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('subproject_id', \"subproject_id\"))),\n            jsonb_build_object('subproject_id', \"subproject_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"subprojects\"\n          WHERE \"subproject_id\" = NEW.\"subproject_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_subproject_users_subproject_id_into_oplog\n  AFTER UPDATE ON \"public\".\"subproject_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_subproject_users_subproject_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_subproject_users_user_id_into_oplog ON \"public\".\"subproject_users\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_subproject_users_user_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_users';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'users',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('user_id', \"user_id\"))),\n            jsonb_build_object('user_id', \"user_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"users\"\n          WHERE \"user_id\" = NEW.\"user_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_subproject_users_user_id_into_oplog\n  AFTER INSERT ON \"public\".\"subproject_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_subproject_users_user_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_subproject_users_user_id_into_oplog ON \"public\".\"subproject_users\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_subproject_users_user_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_users';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'users',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('user_id', \"user_id\"))),\n            jsonb_build_object('user_id', \"user_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"users\"\n          WHERE \"user_id\" = NEW.\"user_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_subproject_users_user_id_into_oplog\n  AFTER UPDATE ON \"public\".\"subproject_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_subproject_users_user_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'taxonomies', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_taxonomies_primarykey ON \"public\".\"taxonomies\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_taxonomies_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"taxonomy_id\" IS DISTINCT FROM NEW.\"taxonomy_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column taxonomy_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_taxonomies_primarykey\n  BEFORE UPDATE ON \"public\".\"taxonomies\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_taxonomies_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_taxonomies_into_oplog ON \"public\".\"taxonomies\";",
      "    CREATE OR REPLACE FUNCTION insert_public_taxonomies_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'taxonomies';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'taxonomies',\n            'INSERT',\n            json_strip_nulls(json_build_object('taxonomy_id', new.\"taxonomy_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'name', new.\"name\", 'obsolete', new.\"obsolete\", 'project_id', new.\"project_id\", 'taxonomy_id', new.\"taxonomy_id\", 'type', new.\"type\", 'url', new.\"url\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_taxonomies_into_oplog\n  AFTER INSERT ON \"public\".\"taxonomies\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_taxonomies_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_taxonomies_into_oplog ON \"public\".\"taxonomies\";",
      "    CREATE OR REPLACE FUNCTION update_public_taxonomies_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'taxonomies';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'taxonomies',\n            'UPDATE',\n            json_strip_nulls(json_build_object('taxonomy_id', new.\"taxonomy_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'name', new.\"name\", 'obsolete', new.\"obsolete\", 'project_id', new.\"project_id\", 'taxonomy_id', new.\"taxonomy_id\", 'type', new.\"type\", 'url', new.\"url\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'name', old.\"name\", 'obsolete', old.\"obsolete\", 'project_id', old.\"project_id\", 'taxonomy_id', old.\"taxonomy_id\", 'type', old.\"type\", 'url', old.\"url\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_taxonomies_into_oplog\n  AFTER UPDATE ON \"public\".\"taxonomies\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_taxonomies_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_taxonomies_into_oplog ON \"public\".\"taxonomies\";",
      "    CREATE OR REPLACE FUNCTION delete_public_taxonomies_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'taxonomies';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'taxonomies',\n            'DELETE',\n            json_strip_nulls(json_build_object('taxonomy_id', old.\"taxonomy_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'name', old.\"name\", 'obsolete', old.\"obsolete\", 'project_id', old.\"project_id\", 'taxonomy_id', old.\"taxonomy_id\", 'type', old.\"type\", 'url', old.\"url\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_taxonomies_into_oplog\n  AFTER DELETE ON \"public\".\"taxonomies\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_taxonomies_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_taxonomies_account_id_into_oplog ON \"public\".\"taxonomies\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_taxonomies_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'taxonomies';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_taxonomies_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"taxonomies\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_taxonomies_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_taxonomies_account_id_into_oplog ON \"public\".\"taxonomies\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_taxonomies_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'taxonomies';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_taxonomies_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"taxonomies\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_taxonomies_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_taxonomies_project_id_into_oplog ON \"public\".\"taxonomies\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_taxonomies_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'taxonomies';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_taxonomies_project_id_into_oplog\n  AFTER INSERT ON \"public\".\"taxonomies\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_taxonomies_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_taxonomies_project_id_into_oplog ON \"public\".\"taxonomies\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_taxonomies_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'taxonomies';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_taxonomies_project_id_into_oplog\n  AFTER UPDATE ON \"public\".\"taxonomies\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_taxonomies_project_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'taxa', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_taxa_primarykey ON \"public\".\"taxa\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_taxa_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"taxon_id\" IS DISTINCT FROM NEW.\"taxon_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column taxon_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_taxa_primarykey\n  BEFORE UPDATE ON \"public\".\"taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_taxa_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_taxa_into_oplog ON \"public\".\"taxa\";",
      "    CREATE OR REPLACE FUNCTION insert_public_taxa_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'taxa';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'taxa',\n            'INSERT',\n            json_strip_nulls(json_build_object('taxon_id', new.\"taxon_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'id_in_source', new.\"id_in_source\", 'label', new.\"label\", 'name', new.\"name\", 'taxon_id', new.\"taxon_id\", 'taxonomy_id', new.\"taxonomy_id\", 'url', new.\"url\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_taxa_into_oplog\n  AFTER INSERT ON \"public\".\"taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_taxa_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_taxa_into_oplog ON \"public\".\"taxa\";",
      "    CREATE OR REPLACE FUNCTION update_public_taxa_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'taxa';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'taxa',\n            'UPDATE',\n            json_strip_nulls(json_build_object('taxon_id', new.\"taxon_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'id_in_source', new.\"id_in_source\", 'label', new.\"label\", 'name', new.\"name\", 'taxon_id', new.\"taxon_id\", 'taxonomy_id', new.\"taxonomy_id\", 'url', new.\"url\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'id_in_source', old.\"id_in_source\", 'label', old.\"label\", 'name', old.\"name\", 'taxon_id', old.\"taxon_id\", 'taxonomy_id', old.\"taxonomy_id\", 'url', old.\"url\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_taxa_into_oplog\n  AFTER UPDATE ON \"public\".\"taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_taxa_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_taxa_into_oplog ON \"public\".\"taxa\";",
      "    CREATE OR REPLACE FUNCTION delete_public_taxa_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'taxa';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'taxa',\n            'DELETE',\n            json_strip_nulls(json_build_object('taxon_id', old.\"taxon_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'id_in_source', old.\"id_in_source\", 'label', old.\"label\", 'name', old.\"name\", 'taxon_id', old.\"taxon_id\", 'taxonomy_id', old.\"taxonomy_id\", 'url', old.\"url\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_taxa_into_oplog\n  AFTER DELETE ON \"public\".\"taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_taxa_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_taxa_account_id_into_oplog ON \"public\".\"taxa\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_taxa_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'taxa';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_taxa_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_taxa_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_taxa_account_id_into_oplog ON \"public\".\"taxa\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_taxa_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'taxa';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_taxa_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_taxa_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_taxa_taxonomy_id_into_oplog ON \"public\".\"taxa\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_taxa_taxonomy_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'taxa';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'taxonomies',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('taxonomy_id', \"taxonomy_id\"))),\n            jsonb_build_object('taxonomy_id', \"taxonomy_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"taxonomies\"\n          WHERE \"taxonomy_id\" = NEW.\"taxonomy_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_taxa_taxonomy_id_into_oplog\n  AFTER INSERT ON \"public\".\"taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_taxa_taxonomy_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_taxa_taxonomy_id_into_oplog ON \"public\".\"taxa\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_taxa_taxonomy_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'taxa';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'taxonomies',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('taxonomy_id', \"taxonomy_id\"))),\n            jsonb_build_object('taxonomy_id', \"taxonomy_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"taxonomies\"\n          WHERE \"taxonomy_id\" = NEW.\"taxonomy_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_taxa_taxonomy_id_into_oplog\n  AFTER UPDATE ON \"public\".\"taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_taxa_taxonomy_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'subproject_taxa', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_subproject_taxa_primarykey ON \"public\".\"subproject_taxa\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_subproject_taxa_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"subproject_taxon_id\" IS DISTINCT FROM NEW.\"subproject_taxon_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column subproject_taxon_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_subproject_taxa_primarykey\n  BEFORE UPDATE ON \"public\".\"subproject_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_subproject_taxa_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_subproject_taxa_into_oplog ON \"public\".\"subproject_taxa\";",
      "    CREATE OR REPLACE FUNCTION insert_public_subproject_taxa_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_taxa';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'subproject_taxa',\n            'INSERT',\n            json_strip_nulls(json_build_object('subproject_taxon_id', new.\"subproject_taxon_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label', new.\"label\", 'subproject_id', new.\"subproject_id\", 'subproject_taxon_id', new.\"subproject_taxon_id\", 'taxon_id', new.\"taxon_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_subproject_taxa_into_oplog\n  AFTER INSERT ON \"public\".\"subproject_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_subproject_taxa_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_subproject_taxa_into_oplog ON \"public\".\"subproject_taxa\";",
      "    CREATE OR REPLACE FUNCTION update_public_subproject_taxa_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_taxa';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'subproject_taxa',\n            'UPDATE',\n            json_strip_nulls(json_build_object('subproject_taxon_id', new.\"subproject_taxon_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label', new.\"label\", 'subproject_id', new.\"subproject_id\", 'subproject_taxon_id', new.\"subproject_taxon_id\", 'taxon_id', new.\"taxon_id\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'label', old.\"label\", 'subproject_id', old.\"subproject_id\", 'subproject_taxon_id', old.\"subproject_taxon_id\", 'taxon_id', old.\"taxon_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_subproject_taxa_into_oplog\n  AFTER UPDATE ON \"public\".\"subproject_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_subproject_taxa_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_subproject_taxa_into_oplog ON \"public\".\"subproject_taxa\";",
      "    CREATE OR REPLACE FUNCTION delete_public_subproject_taxa_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_taxa';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'subproject_taxa',\n            'DELETE',\n            json_strip_nulls(json_build_object('subproject_taxon_id', old.\"subproject_taxon_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'label', old.\"label\", 'subproject_id', old.\"subproject_id\", 'subproject_taxon_id', old.\"subproject_taxon_id\", 'taxon_id', old.\"taxon_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_subproject_taxa_into_oplog\n  AFTER DELETE ON \"public\".\"subproject_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_subproject_taxa_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_subproject_taxa_account_id_into_oplog ON \"public\".\"subproject_taxa\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_subproject_taxa_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_taxa';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_subproject_taxa_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"subproject_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_subproject_taxa_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_subproject_taxa_account_id_into_oplog ON \"public\".\"subproject_taxa\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_subproject_taxa_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_taxa';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_subproject_taxa_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"subproject_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_subproject_taxa_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_subproject_taxa_subproject_id_into_oplog ON \"public\".\"subproject_taxa\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_subproject_taxa_subproject_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_taxa';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'subprojects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('subproject_id', \"subproject_id\"))),\n            jsonb_build_object('subproject_id', \"subproject_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"subprojects\"\n          WHERE \"subproject_id\" = NEW.\"subproject_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_subproject_taxa_subproject_id_into_oplog\n  AFTER INSERT ON \"public\".\"subproject_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_subproject_taxa_subproject_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_subproject_taxa_subproject_id_into_oplog ON \"public\".\"subproject_taxa\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_subproject_taxa_subproject_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_taxa';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'subprojects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('subproject_id', \"subproject_id\"))),\n            jsonb_build_object('subproject_id', \"subproject_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"subprojects\"\n          WHERE \"subproject_id\" = NEW.\"subproject_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_subproject_taxa_subproject_id_into_oplog\n  AFTER UPDATE ON \"public\".\"subproject_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_subproject_taxa_subproject_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_subproject_taxa_taxon_id_into_oplog ON \"public\".\"subproject_taxa\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_subproject_taxa_taxon_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_taxa';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'taxa',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('taxon_id', \"taxon_id\"))),\n            jsonb_build_object('taxon_id', \"taxon_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"taxa\"\n          WHERE \"taxon_id\" = NEW.\"taxon_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_subproject_taxa_taxon_id_into_oplog\n  AFTER INSERT ON \"public\".\"subproject_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_subproject_taxa_taxon_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_subproject_taxa_taxon_id_into_oplog ON \"public\".\"subproject_taxa\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_subproject_taxa_taxon_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_taxa';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'taxa',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('taxon_id', \"taxon_id\"))),\n            jsonb_build_object('taxon_id', \"taxon_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"taxa\"\n          WHERE \"taxon_id\" = NEW.\"taxon_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_subproject_taxa_taxon_id_into_oplog\n  AFTER UPDATE ON \"public\".\"subproject_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_subproject_taxa_taxon_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'lists', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_lists_primarykey ON \"public\".\"lists\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_lists_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"list_id\" IS DISTINCT FROM NEW.\"list_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column list_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_lists_primarykey\n  BEFORE UPDATE ON \"public\".\"lists\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_lists_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_lists_into_oplog ON \"public\".\"lists\";",
      "    CREATE OR REPLACE FUNCTION insert_public_lists_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'lists';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'lists',\n            'INSERT',\n            json_strip_nulls(json_build_object('list_id', new.\"list_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'list_id', new.\"list_id\", 'name', new.\"name\", 'obsolete', new.\"obsolete\", 'project_id', new.\"project_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_lists_into_oplog\n  AFTER INSERT ON \"public\".\"lists\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_lists_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_lists_into_oplog ON \"public\".\"lists\";",
      "    CREATE OR REPLACE FUNCTION update_public_lists_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'lists';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'lists',\n            'UPDATE',\n            json_strip_nulls(json_build_object('list_id', new.\"list_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'list_id', new.\"list_id\", 'name', new.\"name\", 'obsolete', new.\"obsolete\", 'project_id', new.\"project_id\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'list_id', old.\"list_id\", 'name', old.\"name\", 'obsolete', old.\"obsolete\", 'project_id', old.\"project_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_lists_into_oplog\n  AFTER UPDATE ON \"public\".\"lists\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_lists_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_lists_into_oplog ON \"public\".\"lists\";",
      "    CREATE OR REPLACE FUNCTION delete_public_lists_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'lists';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'lists',\n            'DELETE',\n            json_strip_nulls(json_build_object('list_id', old.\"list_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'list_id', old.\"list_id\", 'name', old.\"name\", 'obsolete', old.\"obsolete\", 'project_id', old.\"project_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_lists_into_oplog\n  AFTER DELETE ON \"public\".\"lists\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_lists_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_lists_account_id_into_oplog ON \"public\".\"lists\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_lists_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'lists';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_lists_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"lists\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_lists_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_lists_account_id_into_oplog ON \"public\".\"lists\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_lists_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'lists';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_lists_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"lists\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_lists_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_lists_project_id_into_oplog ON \"public\".\"lists\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_lists_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'lists';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_lists_project_id_into_oplog\n  AFTER INSERT ON \"public\".\"lists\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_lists_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_lists_project_id_into_oplog ON \"public\".\"lists\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_lists_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'lists';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_lists_project_id_into_oplog\n  AFTER UPDATE ON \"public\".\"lists\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_lists_project_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'list_values', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_list_values_primarykey ON \"public\".\"list_values\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_list_values_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"list_value_id\" IS DISTINCT FROM NEW.\"list_value_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column list_value_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_list_values_primarykey\n  BEFORE UPDATE ON \"public\".\"list_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_list_values_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_list_values_into_oplog ON \"public\".\"list_values\";",
      "    CREATE OR REPLACE FUNCTION insert_public_list_values_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'list_values';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'list_values',\n            'INSERT',\n            json_strip_nulls(json_build_object('list_value_id', new.\"list_value_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'list_id', new.\"list_id\", 'list_value_id', new.\"list_value_id\", 'obsolete', new.\"obsolete\", 'value', new.\"value\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_list_values_into_oplog\n  AFTER INSERT ON \"public\".\"list_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_list_values_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_list_values_into_oplog ON \"public\".\"list_values\";",
      "    CREATE OR REPLACE FUNCTION update_public_list_values_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'list_values';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'list_values',\n            'UPDATE',\n            json_strip_nulls(json_build_object('list_value_id', new.\"list_value_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'list_id', new.\"list_id\", 'list_value_id', new.\"list_value_id\", 'obsolete', new.\"obsolete\", 'value', new.\"value\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'list_id', old.\"list_id\", 'list_value_id', old.\"list_value_id\", 'obsolete', old.\"obsolete\", 'value', old.\"value\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_list_values_into_oplog\n  AFTER UPDATE ON \"public\".\"list_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_list_values_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_list_values_into_oplog ON \"public\".\"list_values\";",
      "    CREATE OR REPLACE FUNCTION delete_public_list_values_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'list_values';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'list_values',\n            'DELETE',\n            json_strip_nulls(json_build_object('list_value_id', old.\"list_value_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'list_id', old.\"list_id\", 'list_value_id', old.\"list_value_id\", 'obsolete', old.\"obsolete\", 'value', old.\"value\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_list_values_into_oplog\n  AFTER DELETE ON \"public\".\"list_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_list_values_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_list_values_account_id_into_oplog ON \"public\".\"list_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_list_values_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'list_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_list_values_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"list_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_list_values_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_list_values_account_id_into_oplog ON \"public\".\"list_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_list_values_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'list_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_list_values_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"list_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_list_values_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_list_values_list_id_into_oplog ON \"public\".\"list_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_list_values_list_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'list_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'lists',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('list_id', \"list_id\"))),\n            jsonb_build_object('list_id', \"list_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"lists\"\n          WHERE \"list_id\" = NEW.\"list_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_list_values_list_id_into_oplog\n  AFTER INSERT ON \"public\".\"list_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_list_values_list_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_list_values_list_id_into_oplog ON \"public\".\"list_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_list_values_list_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'list_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'lists',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('list_id', \"list_id\"))),\n            jsonb_build_object('list_id', \"list_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"lists\"\n          WHERE \"list_id\" = NEW.\"list_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_list_values_list_id_into_oplog\n  AFTER UPDATE ON \"public\".\"list_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_list_values_list_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'units', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_units_primarykey ON \"public\".\"units\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_units_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"unit_id\" IS DISTINCT FROM NEW.\"unit_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column unit_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_units_primarykey\n  BEFORE UPDATE ON \"public\".\"units\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_units_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_units_into_oplog ON \"public\".\"units\";",
      "    CREATE OR REPLACE FUNCTION insert_public_units_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'units';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'units',\n            'INSERT',\n            json_strip_nulls(json_build_object('unit_id', new.\"unit_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'list_id', new.\"list_id\", 'name', new.\"name\", 'project_id', new.\"project_id\", 'sort', new.\"sort\", 'summable', new.\"summable\", 'type', new.\"type\", 'unit_id', new.\"unit_id\", 'use_for_action_report_values', new.\"use_for_action_report_values\", 'use_for_action_values', new.\"use_for_action_values\", 'use_for_check_taxa', new.\"use_for_check_taxa\", 'use_for_check_values', new.\"use_for_check_values\", 'use_for_goal_report_values', new.\"use_for_goal_report_values\", 'use_for_place_report_values', new.\"use_for_place_report_values\", 'use_for_subproject_taxa', new.\"use_for_subproject_taxa\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_units_into_oplog\n  AFTER INSERT ON \"public\".\"units\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_units_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_units_into_oplog ON \"public\".\"units\";",
      "    CREATE OR REPLACE FUNCTION update_public_units_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'units';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'units',\n            'UPDATE',\n            json_strip_nulls(json_build_object('unit_id', new.\"unit_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'list_id', new.\"list_id\", 'name', new.\"name\", 'project_id', new.\"project_id\", 'sort', new.\"sort\", 'summable', new.\"summable\", 'type', new.\"type\", 'unit_id', new.\"unit_id\", 'use_for_action_report_values', new.\"use_for_action_report_values\", 'use_for_action_values', new.\"use_for_action_values\", 'use_for_check_taxa', new.\"use_for_check_taxa\", 'use_for_check_values', new.\"use_for_check_values\", 'use_for_goal_report_values', new.\"use_for_goal_report_values\", 'use_for_place_report_values', new.\"use_for_place_report_values\", 'use_for_subproject_taxa', new.\"use_for_subproject_taxa\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'list_id', old.\"list_id\", 'name', old.\"name\", 'project_id', old.\"project_id\", 'sort', old.\"sort\", 'summable', old.\"summable\", 'type', old.\"type\", 'unit_id', old.\"unit_id\", 'use_for_action_report_values', old.\"use_for_action_report_values\", 'use_for_action_values', old.\"use_for_action_values\", 'use_for_check_taxa', old.\"use_for_check_taxa\", 'use_for_check_values', old.\"use_for_check_values\", 'use_for_goal_report_values', old.\"use_for_goal_report_values\", 'use_for_place_report_values', old.\"use_for_place_report_values\", 'use_for_subproject_taxa', old.\"use_for_subproject_taxa\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_units_into_oplog\n  AFTER UPDATE ON \"public\".\"units\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_units_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_units_into_oplog ON \"public\".\"units\";",
      "    CREATE OR REPLACE FUNCTION delete_public_units_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'units';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'units',\n            'DELETE',\n            json_strip_nulls(json_build_object('unit_id', old.\"unit_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'list_id', old.\"list_id\", 'name', old.\"name\", 'project_id', old.\"project_id\", 'sort', old.\"sort\", 'summable', old.\"summable\", 'type', old.\"type\", 'unit_id', old.\"unit_id\", 'use_for_action_report_values', old.\"use_for_action_report_values\", 'use_for_action_values', old.\"use_for_action_values\", 'use_for_check_taxa', old.\"use_for_check_taxa\", 'use_for_check_values', old.\"use_for_check_values\", 'use_for_goal_report_values', old.\"use_for_goal_report_values\", 'use_for_place_report_values', old.\"use_for_place_report_values\", 'use_for_subproject_taxa', old.\"use_for_subproject_taxa\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_units_into_oplog\n  AFTER DELETE ON \"public\".\"units\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_units_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_units_account_id_into_oplog ON \"public\".\"units\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_units_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'units';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_units_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"units\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_units_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_units_account_id_into_oplog ON \"public\".\"units\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_units_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'units';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_units_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"units\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_units_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_units_list_id_into_oplog ON \"public\".\"units\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_units_list_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'units';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'lists',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('list_id', \"list_id\"))),\n            jsonb_build_object('list_id', \"list_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"lists\"\n          WHERE \"list_id\" = NEW.\"list_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_units_list_id_into_oplog\n  AFTER INSERT ON \"public\".\"units\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_units_list_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_units_list_id_into_oplog ON \"public\".\"units\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_units_list_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'units';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'lists',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('list_id', \"list_id\"))),\n            jsonb_build_object('list_id', \"list_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"lists\"\n          WHERE \"list_id\" = NEW.\"list_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_units_list_id_into_oplog\n  AFTER UPDATE ON \"public\".\"units\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_units_list_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_units_project_id_into_oplog ON \"public\".\"units\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_units_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'units';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_units_project_id_into_oplog\n  AFTER INSERT ON \"public\".\"units\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_units_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_units_project_id_into_oplog ON \"public\".\"units\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_units_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'units';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_units_project_id_into_oplog\n  AFTER UPDATE ON \"public\".\"units\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_units_project_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'places', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_places_primarykey ON \"public\".\"places\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_places_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"place_id\" IS DISTINCT FROM NEW.\"place_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column place_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_places_primarykey\n  BEFORE UPDATE ON \"public\".\"places\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_places_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_places_into_oplog ON \"public\".\"places\";",
      "    CREATE OR REPLACE FUNCTION insert_public_places_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'places';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'places',\n            'INSERT',\n            json_strip_nulls(json_build_object('place_id', new.\"place_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'bbox', new.\"bbox\", 'data', new.\"data\", 'files_active_places', new.\"files_active_places\", 'geometry', new.\"geometry\", 'label', new.\"label\", 'level', new.\"level\", 'parent_id', new.\"parent_id\", 'place_id', new.\"place_id\", 'since', new.\"since\", 'subproject_id', new.\"subproject_id\", 'until', new.\"until\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_places_into_oplog\n  AFTER INSERT ON \"public\".\"places\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_places_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_places_into_oplog ON \"public\".\"places\";",
      "    CREATE OR REPLACE FUNCTION update_public_places_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'places';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'places',\n            'UPDATE',\n            json_strip_nulls(json_build_object('place_id', new.\"place_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'bbox', new.\"bbox\", 'data', new.\"data\", 'files_active_places', new.\"files_active_places\", 'geometry', new.\"geometry\", 'label', new.\"label\", 'level', new.\"level\", 'parent_id', new.\"parent_id\", 'place_id', new.\"place_id\", 'since', new.\"since\", 'subproject_id', new.\"subproject_id\", 'until', new.\"until\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'bbox', old.\"bbox\", 'data', old.\"data\", 'files_active_places', old.\"files_active_places\", 'geometry', old.\"geometry\", 'label', old.\"label\", 'level', old.\"level\", 'parent_id', old.\"parent_id\", 'place_id', old.\"place_id\", 'since', old.\"since\", 'subproject_id', old.\"subproject_id\", 'until', old.\"until\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_places_into_oplog\n  AFTER UPDATE ON \"public\".\"places\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_places_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_places_into_oplog ON \"public\".\"places\";",
      "    CREATE OR REPLACE FUNCTION delete_public_places_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'places';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'places',\n            'DELETE',\n            json_strip_nulls(json_build_object('place_id', old.\"place_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'bbox', old.\"bbox\", 'data', old.\"data\", 'files_active_places', old.\"files_active_places\", 'geometry', old.\"geometry\", 'label', old.\"label\", 'level', old.\"level\", 'parent_id', old.\"parent_id\", 'place_id', old.\"place_id\", 'since', old.\"since\", 'subproject_id', old.\"subproject_id\", 'until', old.\"until\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_places_into_oplog\n  AFTER DELETE ON \"public\".\"places\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_places_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_places_account_id_into_oplog ON \"public\".\"places\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_places_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'places';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_places_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"places\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_places_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_places_account_id_into_oplog ON \"public\".\"places\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_places_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'places';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_places_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"places\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_places_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_places_parent_id_into_oplog ON \"public\".\"places\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_places_parent_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'places';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'places',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('place_id', \"place_id\"))),\n            jsonb_build_object('place_id', \"place_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"places\"\n          WHERE \"place_id\" = NEW.\"parent_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_places_parent_id_into_oplog\n  AFTER INSERT ON \"public\".\"places\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_places_parent_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_places_parent_id_into_oplog ON \"public\".\"places\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_places_parent_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'places';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'places',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('place_id', \"place_id\"))),\n            jsonb_build_object('place_id', \"place_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"places\"\n          WHERE \"place_id\" = NEW.\"parent_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_places_parent_id_into_oplog\n  AFTER UPDATE ON \"public\".\"places\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_places_parent_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_places_subproject_id_into_oplog ON \"public\".\"places\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_places_subproject_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'places';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'subprojects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('subproject_id', \"subproject_id\"))),\n            jsonb_build_object('subproject_id', \"subproject_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"subprojects\"\n          WHERE \"subproject_id\" = NEW.\"subproject_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_places_subproject_id_into_oplog\n  AFTER INSERT ON \"public\".\"places\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_places_subproject_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_places_subproject_id_into_oplog ON \"public\".\"places\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_places_subproject_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'places';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'subprojects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('subproject_id', \"subproject_id\"))),\n            jsonb_build_object('subproject_id', \"subproject_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"subprojects\"\n          WHERE \"subproject_id\" = NEW.\"subproject_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_places_subproject_id_into_oplog\n  AFTER UPDATE ON \"public\".\"places\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_places_subproject_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'actions', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_actions_primarykey ON \"public\".\"actions\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_actions_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"action_id\" IS DISTINCT FROM NEW.\"action_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column action_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_actions_primarykey\n  BEFORE UPDATE ON \"public\".\"actions\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_actions_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_actions_into_oplog ON \"public\".\"actions\";",
      "    CREATE OR REPLACE FUNCTION insert_public_actions_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'actions';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'actions',\n            'INSERT',\n            json_strip_nulls(json_build_object('action_id', new.\"action_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'action_id', new.\"action_id\", 'bbox', new.\"bbox\", 'data', new.\"data\", 'date', new.\"date\", 'geometry', new.\"geometry\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'place_id', new.\"place_id\", 'relevant_for_reports', new.\"relevant_for_reports\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_actions_into_oplog\n  AFTER INSERT ON \"public\".\"actions\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_actions_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_actions_into_oplog ON \"public\".\"actions\";",
      "    CREATE OR REPLACE FUNCTION update_public_actions_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'actions';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'actions',\n            'UPDATE',\n            json_strip_nulls(json_build_object('action_id', new.\"action_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'action_id', new.\"action_id\", 'bbox', new.\"bbox\", 'data', new.\"data\", 'date', new.\"date\", 'geometry', new.\"geometry\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'place_id', new.\"place_id\", 'relevant_for_reports', new.\"relevant_for_reports\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'action_id', old.\"action_id\", 'bbox', old.\"bbox\", 'data', old.\"data\", 'date', old.\"date\", 'geometry', old.\"geometry\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'place_id', old.\"place_id\", 'relevant_for_reports', old.\"relevant_for_reports\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_actions_into_oplog\n  AFTER UPDATE ON \"public\".\"actions\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_actions_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_actions_into_oplog ON \"public\".\"actions\";",
      "    CREATE OR REPLACE FUNCTION delete_public_actions_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'actions';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'actions',\n            'DELETE',\n            json_strip_nulls(json_build_object('action_id', old.\"action_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'action_id', old.\"action_id\", 'bbox', old.\"bbox\", 'data', old.\"data\", 'date', old.\"date\", 'geometry', old.\"geometry\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'place_id', old.\"place_id\", 'relevant_for_reports', old.\"relevant_for_reports\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_actions_into_oplog\n  AFTER DELETE ON \"public\".\"actions\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_actions_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_actions_account_id_into_oplog ON \"public\".\"actions\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_actions_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'actions';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_actions_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"actions\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_actions_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_actions_account_id_into_oplog ON \"public\".\"actions\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_actions_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'actions';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_actions_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"actions\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_actions_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_actions_place_id_into_oplog ON \"public\".\"actions\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_actions_place_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'actions';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'places',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('place_id', \"place_id\"))),\n            jsonb_build_object('place_id', \"place_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"places\"\n          WHERE \"place_id\" = NEW.\"place_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_actions_place_id_into_oplog\n  AFTER INSERT ON \"public\".\"actions\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_actions_place_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_actions_place_id_into_oplog ON \"public\".\"actions\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_actions_place_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'actions';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'places',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('place_id', \"place_id\"))),\n            jsonb_build_object('place_id', \"place_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"places\"\n          WHERE \"place_id\" = NEW.\"place_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_actions_place_id_into_oplog\n  AFTER UPDATE ON \"public\".\"actions\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_actions_place_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'action_values', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_action_values_primarykey ON \"public\".\"action_values\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_action_values_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"action_value_id\" IS DISTINCT FROM NEW.\"action_value_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column action_value_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_action_values_primarykey\n  BEFORE UPDATE ON \"public\".\"action_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_action_values_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_action_values_into_oplog ON \"public\".\"action_values\";",
      "    CREATE OR REPLACE FUNCTION insert_public_action_values_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_values';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'action_values',\n            'INSERT',\n            json_strip_nulls(json_build_object('action_value_id', new.\"action_value_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'action_id', new.\"action_id\", 'action_value_id', new.\"action_value_id\", 'label', new.\"label\", 'unit_id', new.\"unit_id\", 'value_integer', new.\"value_integer\", 'value_numeric', cast(new.\"value_numeric\" as TEXT), 'value_text', new.\"value_text\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_action_values_into_oplog\n  AFTER INSERT ON \"public\".\"action_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_action_values_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_action_values_into_oplog ON \"public\".\"action_values\";",
      "    CREATE OR REPLACE FUNCTION update_public_action_values_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_values';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'action_values',\n            'UPDATE',\n            json_strip_nulls(json_build_object('action_value_id', new.\"action_value_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'action_id', new.\"action_id\", 'action_value_id', new.\"action_value_id\", 'label', new.\"label\", 'unit_id', new.\"unit_id\", 'value_integer', new.\"value_integer\", 'value_numeric', cast(new.\"value_numeric\" as TEXT), 'value_text', new.\"value_text\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'action_id', old.\"action_id\", 'action_value_id', old.\"action_value_id\", 'label', old.\"label\", 'unit_id', old.\"unit_id\", 'value_integer', old.\"value_integer\", 'value_numeric', cast(old.\"value_numeric\" as TEXT), 'value_text', old.\"value_text\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_action_values_into_oplog\n  AFTER UPDATE ON \"public\".\"action_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_action_values_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_action_values_into_oplog ON \"public\".\"action_values\";",
      "    CREATE OR REPLACE FUNCTION delete_public_action_values_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_values';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'action_values',\n            'DELETE',\n            json_strip_nulls(json_build_object('action_value_id', old.\"action_value_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'action_id', old.\"action_id\", 'action_value_id', old.\"action_value_id\", 'label', old.\"label\", 'unit_id', old.\"unit_id\", 'value_integer', old.\"value_integer\", 'value_numeric', cast(old.\"value_numeric\" as TEXT), 'value_text', old.\"value_text\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_action_values_into_oplog\n  AFTER DELETE ON \"public\".\"action_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_action_values_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_action_values_account_id_into_oplog ON \"public\".\"action_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_action_values_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_action_values_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"action_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_action_values_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_action_values_account_id_into_oplog ON \"public\".\"action_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_action_values_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_action_values_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"action_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_action_values_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_action_values_action_id_into_oplog ON \"public\".\"action_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_action_values_action_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'actions',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('action_id', \"action_id\"))),\n            jsonb_build_object('action_id', \"action_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"actions\"\n          WHERE \"action_id\" = NEW.\"action_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_action_values_action_id_into_oplog\n  AFTER INSERT ON \"public\".\"action_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_action_values_action_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_action_values_action_id_into_oplog ON \"public\".\"action_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_action_values_action_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'actions',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('action_id', \"action_id\"))),\n            jsonb_build_object('action_id', \"action_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"actions\"\n          WHERE \"action_id\" = NEW.\"action_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_action_values_action_id_into_oplog\n  AFTER UPDATE ON \"public\".\"action_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_action_values_action_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_action_values_unit_id_into_oplog ON \"public\".\"action_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_action_values_unit_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'units',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('unit_id', \"unit_id\"))),\n            jsonb_build_object('unit_id', \"unit_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"units\"\n          WHERE \"unit_id\" = NEW.\"unit_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_action_values_unit_id_into_oplog\n  AFTER INSERT ON \"public\".\"action_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_action_values_unit_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_action_values_unit_id_into_oplog ON \"public\".\"action_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_action_values_unit_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'units',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('unit_id', \"unit_id\"))),\n            jsonb_build_object('unit_id', \"unit_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"units\"\n          WHERE \"unit_id\" = NEW.\"unit_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_action_values_unit_id_into_oplog\n  AFTER UPDATE ON \"public\".\"action_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_action_values_unit_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'action_reports', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_action_reports_primarykey ON \"public\".\"action_reports\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_action_reports_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"action_report_id\" IS DISTINCT FROM NEW.\"action_report_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column action_report_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_action_reports_primarykey\n  BEFORE UPDATE ON \"public\".\"action_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_action_reports_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_action_reports_into_oplog ON \"public\".\"action_reports\";",
      "    CREATE OR REPLACE FUNCTION insert_public_action_reports_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_reports';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'action_reports',\n            'INSERT',\n            json_strip_nulls(json_build_object('action_report_id', new.\"action_report_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'action_id', new.\"action_id\", 'action_report_id', new.\"action_report_id\", 'data', new.\"data\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'year', new.\"year\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_action_reports_into_oplog\n  AFTER INSERT ON \"public\".\"action_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_action_reports_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_action_reports_into_oplog ON \"public\".\"action_reports\";",
      "    CREATE OR REPLACE FUNCTION update_public_action_reports_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_reports';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'action_reports',\n            'UPDATE',\n            json_strip_nulls(json_build_object('action_report_id', new.\"action_report_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'action_id', new.\"action_id\", 'action_report_id', new.\"action_report_id\", 'data', new.\"data\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'year', new.\"year\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'action_id', old.\"action_id\", 'action_report_id', old.\"action_report_id\", 'data', old.\"data\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'year', old.\"year\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_action_reports_into_oplog\n  AFTER UPDATE ON \"public\".\"action_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_action_reports_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_action_reports_into_oplog ON \"public\".\"action_reports\";",
      "    CREATE OR REPLACE FUNCTION delete_public_action_reports_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_reports';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'action_reports',\n            'DELETE',\n            json_strip_nulls(json_build_object('action_report_id', old.\"action_report_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'action_id', old.\"action_id\", 'action_report_id', old.\"action_report_id\", 'data', old.\"data\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'year', old.\"year\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_action_reports_into_oplog\n  AFTER DELETE ON \"public\".\"action_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_action_reports_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_action_reports_account_id_into_oplog ON \"public\".\"action_reports\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_action_reports_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_reports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_action_reports_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"action_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_action_reports_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_action_reports_account_id_into_oplog ON \"public\".\"action_reports\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_action_reports_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_reports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_action_reports_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"action_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_action_reports_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_action_reports_action_id_into_oplog ON \"public\".\"action_reports\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_action_reports_action_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_reports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'actions',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('action_id', \"action_id\"))),\n            jsonb_build_object('action_id', \"action_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"actions\"\n          WHERE \"action_id\" = NEW.\"action_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_action_reports_action_id_into_oplog\n  AFTER INSERT ON \"public\".\"action_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_action_reports_action_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_action_reports_action_id_into_oplog ON \"public\".\"action_reports\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_action_reports_action_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_reports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'actions',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('action_id', \"action_id\"))),\n            jsonb_build_object('action_id', \"action_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"actions\"\n          WHERE \"action_id\" = NEW.\"action_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_action_reports_action_id_into_oplog\n  AFTER UPDATE ON \"public\".\"action_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_action_reports_action_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'action_report_values', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_action_report_values_primarykey ON \"public\".\"action_report_values\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_action_report_values_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"action_report_value_id\" IS DISTINCT FROM NEW.\"action_report_value_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column action_report_value_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_action_report_values_primarykey\n  BEFORE UPDATE ON \"public\".\"action_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_action_report_values_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_action_report_values_into_oplog ON \"public\".\"action_report_values\";",
      "    CREATE OR REPLACE FUNCTION insert_public_action_report_values_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_report_values';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'action_report_values',\n            'INSERT',\n            json_strip_nulls(json_build_object('action_report_value_id', new.\"action_report_value_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'action_report_id', new.\"action_report_id\", 'action_report_value_id', new.\"action_report_value_id\", 'label', new.\"label\", 'unit_id', new.\"unit_id\", 'value_integer', new.\"value_integer\", 'value_numeric', cast(new.\"value_numeric\" as TEXT), 'value_text', new.\"value_text\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_action_report_values_into_oplog\n  AFTER INSERT ON \"public\".\"action_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_action_report_values_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_action_report_values_into_oplog ON \"public\".\"action_report_values\";",
      "    CREATE OR REPLACE FUNCTION update_public_action_report_values_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_report_values';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'action_report_values',\n            'UPDATE',\n            json_strip_nulls(json_build_object('action_report_value_id', new.\"action_report_value_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'action_report_id', new.\"action_report_id\", 'action_report_value_id', new.\"action_report_value_id\", 'label', new.\"label\", 'unit_id', new.\"unit_id\", 'value_integer', new.\"value_integer\", 'value_numeric', cast(new.\"value_numeric\" as TEXT), 'value_text', new.\"value_text\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'action_report_id', old.\"action_report_id\", 'action_report_value_id', old.\"action_report_value_id\", 'label', old.\"label\", 'unit_id', old.\"unit_id\", 'value_integer', old.\"value_integer\", 'value_numeric', cast(old.\"value_numeric\" as TEXT), 'value_text', old.\"value_text\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_action_report_values_into_oplog\n  AFTER UPDATE ON \"public\".\"action_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_action_report_values_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_action_report_values_into_oplog ON \"public\".\"action_report_values\";",
      "    CREATE OR REPLACE FUNCTION delete_public_action_report_values_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_report_values';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'action_report_values',\n            'DELETE',\n            json_strip_nulls(json_build_object('action_report_value_id', old.\"action_report_value_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'action_report_id', old.\"action_report_id\", 'action_report_value_id', old.\"action_report_value_id\", 'label', old.\"label\", 'unit_id', old.\"unit_id\", 'value_integer', old.\"value_integer\", 'value_numeric', cast(old.\"value_numeric\" as TEXT), 'value_text', old.\"value_text\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_action_report_values_into_oplog\n  AFTER DELETE ON \"public\".\"action_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_action_report_values_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_action_report_values_account_id_into_oplog ON \"public\".\"action_report_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_action_report_values_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_report_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_action_report_values_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"action_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_action_report_values_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_action_report_values_account_id_into_oplog ON \"public\".\"action_report_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_action_report_values_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_report_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_action_report_values_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"action_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_action_report_values_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_action_report_values_action_report_id_into_oplog ON \"public\".\"action_report_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_action_report_values_action_report_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_report_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'action_reports',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('action_report_id', \"action_report_id\"))),\n            jsonb_build_object('action_report_id', \"action_report_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"action_reports\"\n          WHERE \"action_report_id\" = NEW.\"action_report_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_action_report_values_action_report_id_into_oplog\n  AFTER INSERT ON \"public\".\"action_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_action_report_values_action_report_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_action_report_values_action_report_id_into_oplog ON \"public\".\"action_report_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_action_report_values_action_report_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_report_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'action_reports',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('action_report_id', \"action_report_id\"))),\n            jsonb_build_object('action_report_id', \"action_report_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"action_reports\"\n          WHERE \"action_report_id\" = NEW.\"action_report_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_action_report_values_action_report_id_into_oplog\n  AFTER UPDATE ON \"public\".\"action_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_action_report_values_action_report_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_action_report_values_unit_id_into_oplog ON \"public\".\"action_report_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_action_report_values_unit_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_report_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'units',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('unit_id', \"unit_id\"))),\n            jsonb_build_object('unit_id', \"unit_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"units\"\n          WHERE \"unit_id\" = NEW.\"unit_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_action_report_values_unit_id_into_oplog\n  AFTER INSERT ON \"public\".\"action_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_action_report_values_unit_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_action_report_values_unit_id_into_oplog ON \"public\".\"action_report_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_action_report_values_unit_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'action_report_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'units',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('unit_id', \"unit_id\"))),\n            jsonb_build_object('unit_id', \"unit_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"units\"\n          WHERE \"unit_id\" = NEW.\"unit_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_action_report_values_unit_id_into_oplog\n  AFTER UPDATE ON \"public\".\"action_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_action_report_values_unit_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'checks', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_checks_primarykey ON \"public\".\"checks\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_checks_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"check_id\" IS DISTINCT FROM NEW.\"check_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column check_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_checks_primarykey\n  BEFORE UPDATE ON \"public\".\"checks\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_checks_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_checks_into_oplog ON \"public\".\"checks\";",
      "    CREATE OR REPLACE FUNCTION insert_public_checks_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'checks';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'checks',\n            'INSERT',\n            json_strip_nulls(json_build_object('check_id', new.\"check_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'bbox', new.\"bbox\", 'check_id', new.\"check_id\", 'data', new.\"data\", 'date', new.\"date\", 'geometry', new.\"geometry\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'place_id', new.\"place_id\", 'relevant_for_reports', new.\"relevant_for_reports\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_checks_into_oplog\n  AFTER INSERT ON \"public\".\"checks\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_checks_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_checks_into_oplog ON \"public\".\"checks\";",
      "    CREATE OR REPLACE FUNCTION update_public_checks_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'checks';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'checks',\n            'UPDATE',\n            json_strip_nulls(json_build_object('check_id', new.\"check_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'bbox', new.\"bbox\", 'check_id', new.\"check_id\", 'data', new.\"data\", 'date', new.\"date\", 'geometry', new.\"geometry\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'place_id', new.\"place_id\", 'relevant_for_reports', new.\"relevant_for_reports\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'bbox', old.\"bbox\", 'check_id', old.\"check_id\", 'data', old.\"data\", 'date', old.\"date\", 'geometry', old.\"geometry\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'place_id', old.\"place_id\", 'relevant_for_reports', old.\"relevant_for_reports\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_checks_into_oplog\n  AFTER UPDATE ON \"public\".\"checks\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_checks_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_checks_into_oplog ON \"public\".\"checks\";",
      "    CREATE OR REPLACE FUNCTION delete_public_checks_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'checks';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'checks',\n            'DELETE',\n            json_strip_nulls(json_build_object('check_id', old.\"check_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'bbox', old.\"bbox\", 'check_id', old.\"check_id\", 'data', old.\"data\", 'date', old.\"date\", 'geometry', old.\"geometry\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'place_id', old.\"place_id\", 'relevant_for_reports', old.\"relevant_for_reports\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_checks_into_oplog\n  AFTER DELETE ON \"public\".\"checks\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_checks_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_checks_account_id_into_oplog ON \"public\".\"checks\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_checks_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'checks';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_checks_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"checks\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_checks_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_checks_account_id_into_oplog ON \"public\".\"checks\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_checks_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'checks';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_checks_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"checks\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_checks_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_checks_place_id_into_oplog ON \"public\".\"checks\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_checks_place_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'checks';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'places',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('place_id', \"place_id\"))),\n            jsonb_build_object('place_id', \"place_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"places\"\n          WHERE \"place_id\" = NEW.\"place_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_checks_place_id_into_oplog\n  AFTER INSERT ON \"public\".\"checks\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_checks_place_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_checks_place_id_into_oplog ON \"public\".\"checks\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_checks_place_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'checks';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'places',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('place_id', \"place_id\"))),\n            jsonb_build_object('place_id', \"place_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"places\"\n          WHERE \"place_id\" = NEW.\"place_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_checks_place_id_into_oplog\n  AFTER UPDATE ON \"public\".\"checks\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_checks_place_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'check_values', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_check_values_primarykey ON \"public\".\"check_values\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_check_values_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"check_value_id\" IS DISTINCT FROM NEW.\"check_value_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column check_value_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_check_values_primarykey\n  BEFORE UPDATE ON \"public\".\"check_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_check_values_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_check_values_into_oplog ON \"public\".\"check_values\";",
      "    CREATE OR REPLACE FUNCTION insert_public_check_values_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'check_values';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'check_values',\n            'INSERT',\n            json_strip_nulls(json_build_object('check_value_id', new.\"check_value_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'check_id', new.\"check_id\", 'check_value_id', new.\"check_value_id\", 'label', new.\"label\", 'unit_id', new.\"unit_id\", 'value_integer', new.\"value_integer\", 'value_numeric', cast(new.\"value_numeric\" as TEXT), 'value_text', new.\"value_text\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_check_values_into_oplog\n  AFTER INSERT ON \"public\".\"check_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_check_values_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_check_values_into_oplog ON \"public\".\"check_values\";",
      "    CREATE OR REPLACE FUNCTION update_public_check_values_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'check_values';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'check_values',\n            'UPDATE',\n            json_strip_nulls(json_build_object('check_value_id', new.\"check_value_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'check_id', new.\"check_id\", 'check_value_id', new.\"check_value_id\", 'label', new.\"label\", 'unit_id', new.\"unit_id\", 'value_integer', new.\"value_integer\", 'value_numeric', cast(new.\"value_numeric\" as TEXT), 'value_text', new.\"value_text\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'check_id', old.\"check_id\", 'check_value_id', old.\"check_value_id\", 'label', old.\"label\", 'unit_id', old.\"unit_id\", 'value_integer', old.\"value_integer\", 'value_numeric', cast(old.\"value_numeric\" as TEXT), 'value_text', old.\"value_text\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_check_values_into_oplog\n  AFTER UPDATE ON \"public\".\"check_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_check_values_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_check_values_into_oplog ON \"public\".\"check_values\";",
      "    CREATE OR REPLACE FUNCTION delete_public_check_values_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'check_values';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'check_values',\n            'DELETE',\n            json_strip_nulls(json_build_object('check_value_id', old.\"check_value_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'check_id', old.\"check_id\", 'check_value_id', old.\"check_value_id\", 'label', old.\"label\", 'unit_id', old.\"unit_id\", 'value_integer', old.\"value_integer\", 'value_numeric', cast(old.\"value_numeric\" as TEXT), 'value_text', old.\"value_text\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_check_values_into_oplog\n  AFTER DELETE ON \"public\".\"check_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_check_values_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_check_values_account_id_into_oplog ON \"public\".\"check_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_check_values_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'check_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_check_values_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"check_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_check_values_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_check_values_account_id_into_oplog ON \"public\".\"check_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_check_values_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'check_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_check_values_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"check_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_check_values_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_check_values_check_id_into_oplog ON \"public\".\"check_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_check_values_check_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'check_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'checks',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('check_id', \"check_id\"))),\n            jsonb_build_object('check_id', \"check_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"checks\"\n          WHERE \"check_id\" = NEW.\"check_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_check_values_check_id_into_oplog\n  AFTER INSERT ON \"public\".\"check_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_check_values_check_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_check_values_check_id_into_oplog ON \"public\".\"check_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_check_values_check_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'check_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'checks',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('check_id', \"check_id\"))),\n            jsonb_build_object('check_id', \"check_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"checks\"\n          WHERE \"check_id\" = NEW.\"check_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_check_values_check_id_into_oplog\n  AFTER UPDATE ON \"public\".\"check_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_check_values_check_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_check_values_unit_id_into_oplog ON \"public\".\"check_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_check_values_unit_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'check_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'units',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('unit_id', \"unit_id\"))),\n            jsonb_build_object('unit_id', \"unit_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"units\"\n          WHERE \"unit_id\" = NEW.\"unit_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_check_values_unit_id_into_oplog\n  AFTER INSERT ON \"public\".\"check_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_check_values_unit_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_check_values_unit_id_into_oplog ON \"public\".\"check_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_check_values_unit_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'check_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'units',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('unit_id', \"unit_id\"))),\n            jsonb_build_object('unit_id', \"unit_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"units\"\n          WHERE \"unit_id\" = NEW.\"unit_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_check_values_unit_id_into_oplog\n  AFTER UPDATE ON \"public\".\"check_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_check_values_unit_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'check_taxa', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_check_taxa_primarykey ON \"public\".\"check_taxa\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_check_taxa_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"check_taxon_id\" IS DISTINCT FROM NEW.\"check_taxon_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column check_taxon_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_check_taxa_primarykey\n  BEFORE UPDATE ON \"public\".\"check_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_check_taxa_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_check_taxa_into_oplog ON \"public\".\"check_taxa\";",
      "    CREATE OR REPLACE FUNCTION insert_public_check_taxa_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'check_taxa';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'check_taxa',\n            'INSERT',\n            json_strip_nulls(json_build_object('check_taxon_id', new.\"check_taxon_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'check_id', new.\"check_id\", 'check_taxon_id', new.\"check_taxon_id\", 'label', new.\"label\", 'taxon_id', new.\"taxon_id\", 'unit_id', new.\"unit_id\", 'value_integer', new.\"value_integer\", 'value_numeric', cast(new.\"value_numeric\" as TEXT), 'value_text', new.\"value_text\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_check_taxa_into_oplog\n  AFTER INSERT ON \"public\".\"check_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_check_taxa_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_check_taxa_into_oplog ON \"public\".\"check_taxa\";",
      "    CREATE OR REPLACE FUNCTION update_public_check_taxa_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'check_taxa';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'check_taxa',\n            'UPDATE',\n            json_strip_nulls(json_build_object('check_taxon_id', new.\"check_taxon_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'check_id', new.\"check_id\", 'check_taxon_id', new.\"check_taxon_id\", 'label', new.\"label\", 'taxon_id', new.\"taxon_id\", 'unit_id', new.\"unit_id\", 'value_integer', new.\"value_integer\", 'value_numeric', cast(new.\"value_numeric\" as TEXT), 'value_text', new.\"value_text\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'check_id', old.\"check_id\", 'check_taxon_id', old.\"check_taxon_id\", 'label', old.\"label\", 'taxon_id', old.\"taxon_id\", 'unit_id', old.\"unit_id\", 'value_integer', old.\"value_integer\", 'value_numeric', cast(old.\"value_numeric\" as TEXT), 'value_text', old.\"value_text\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_check_taxa_into_oplog\n  AFTER UPDATE ON \"public\".\"check_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_check_taxa_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_check_taxa_into_oplog ON \"public\".\"check_taxa\";",
      "    CREATE OR REPLACE FUNCTION delete_public_check_taxa_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'check_taxa';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'check_taxa',\n            'DELETE',\n            json_strip_nulls(json_build_object('check_taxon_id', old.\"check_taxon_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'check_id', old.\"check_id\", 'check_taxon_id', old.\"check_taxon_id\", 'label', old.\"label\", 'taxon_id', old.\"taxon_id\", 'unit_id', old.\"unit_id\", 'value_integer', old.\"value_integer\", 'value_numeric', cast(old.\"value_numeric\" as TEXT), 'value_text', old.\"value_text\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_check_taxa_into_oplog\n  AFTER DELETE ON \"public\".\"check_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_check_taxa_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_check_taxa_account_id_into_oplog ON \"public\".\"check_taxa\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_check_taxa_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'check_taxa';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_check_taxa_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"check_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_check_taxa_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_check_taxa_account_id_into_oplog ON \"public\".\"check_taxa\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_check_taxa_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'check_taxa';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_check_taxa_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"check_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_check_taxa_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_check_taxa_check_id_into_oplog ON \"public\".\"check_taxa\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_check_taxa_check_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'check_taxa';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'checks',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('check_id', \"check_id\"))),\n            jsonb_build_object('check_id', \"check_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"checks\"\n          WHERE \"check_id\" = NEW.\"check_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_check_taxa_check_id_into_oplog\n  AFTER INSERT ON \"public\".\"check_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_check_taxa_check_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_check_taxa_check_id_into_oplog ON \"public\".\"check_taxa\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_check_taxa_check_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'check_taxa';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'checks',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('check_id', \"check_id\"))),\n            jsonb_build_object('check_id', \"check_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"checks\"\n          WHERE \"check_id\" = NEW.\"check_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_check_taxa_check_id_into_oplog\n  AFTER UPDATE ON \"public\".\"check_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_check_taxa_check_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_check_taxa_taxon_id_into_oplog ON \"public\".\"check_taxa\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_check_taxa_taxon_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'check_taxa';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'taxa',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('taxon_id', \"taxon_id\"))),\n            jsonb_build_object('taxon_id', \"taxon_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"taxa\"\n          WHERE \"taxon_id\" = NEW.\"taxon_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_check_taxa_taxon_id_into_oplog\n  AFTER INSERT ON \"public\".\"check_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_check_taxa_taxon_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_check_taxa_taxon_id_into_oplog ON \"public\".\"check_taxa\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_check_taxa_taxon_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'check_taxa';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'taxa',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('taxon_id', \"taxon_id\"))),\n            jsonb_build_object('taxon_id', \"taxon_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"taxa\"\n          WHERE \"taxon_id\" = NEW.\"taxon_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_check_taxa_taxon_id_into_oplog\n  AFTER UPDATE ON \"public\".\"check_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_check_taxa_taxon_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_check_taxa_unit_id_into_oplog ON \"public\".\"check_taxa\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_check_taxa_unit_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'check_taxa';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'units',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('unit_id', \"unit_id\"))),\n            jsonb_build_object('unit_id', \"unit_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"units\"\n          WHERE \"unit_id\" = NEW.\"unit_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_check_taxa_unit_id_into_oplog\n  AFTER INSERT ON \"public\".\"check_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_check_taxa_unit_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_check_taxa_unit_id_into_oplog ON \"public\".\"check_taxa\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_check_taxa_unit_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'check_taxa';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'units',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('unit_id', \"unit_id\"))),\n            jsonb_build_object('unit_id', \"unit_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"units\"\n          WHERE \"unit_id\" = NEW.\"unit_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_check_taxa_unit_id_into_oplog\n  AFTER UPDATE ON \"public\".\"check_taxa\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_check_taxa_unit_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'place_reports', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_place_reports_primarykey ON \"public\".\"place_reports\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_place_reports_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"place_report_id\" IS DISTINCT FROM NEW.\"place_report_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column place_report_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_place_reports_primarykey\n  BEFORE UPDATE ON \"public\".\"place_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_place_reports_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_place_reports_into_oplog ON \"public\".\"place_reports\";",
      "    CREATE OR REPLACE FUNCTION insert_public_place_reports_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_reports';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'place_reports',\n            'INSERT',\n            json_strip_nulls(json_build_object('place_report_id', new.\"place_report_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'place_id', new.\"place_id\", 'place_report_id', new.\"place_report_id\", 'year', new.\"year\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_place_reports_into_oplog\n  AFTER INSERT ON \"public\".\"place_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_place_reports_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_place_reports_into_oplog ON \"public\".\"place_reports\";",
      "    CREATE OR REPLACE FUNCTION update_public_place_reports_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_reports';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'place_reports',\n            'UPDATE',\n            json_strip_nulls(json_build_object('place_report_id', new.\"place_report_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'place_id', new.\"place_id\", 'place_report_id', new.\"place_report_id\", 'year', new.\"year\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'place_id', old.\"place_id\", 'place_report_id', old.\"place_report_id\", 'year', old.\"year\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_place_reports_into_oplog\n  AFTER UPDATE ON \"public\".\"place_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_place_reports_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_place_reports_into_oplog ON \"public\".\"place_reports\";",
      "    CREATE OR REPLACE FUNCTION delete_public_place_reports_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_reports';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'place_reports',\n            'DELETE',\n            json_strip_nulls(json_build_object('place_report_id', old.\"place_report_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'place_id', old.\"place_id\", 'place_report_id', old.\"place_report_id\", 'year', old.\"year\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_place_reports_into_oplog\n  AFTER DELETE ON \"public\".\"place_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_place_reports_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_place_reports_account_id_into_oplog ON \"public\".\"place_reports\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_place_reports_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_reports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_place_reports_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"place_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_place_reports_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_place_reports_account_id_into_oplog ON \"public\".\"place_reports\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_place_reports_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_reports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_place_reports_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"place_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_place_reports_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_place_reports_place_id_into_oplog ON \"public\".\"place_reports\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_place_reports_place_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_reports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'places',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('place_id', \"place_id\"))),\n            jsonb_build_object('place_id', \"place_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"places\"\n          WHERE \"place_id\" = NEW.\"place_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_place_reports_place_id_into_oplog\n  AFTER INSERT ON \"public\".\"place_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_place_reports_place_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_place_reports_place_id_into_oplog ON \"public\".\"place_reports\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_place_reports_place_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_reports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'places',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('place_id', \"place_id\"))),\n            jsonb_build_object('place_id', \"place_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"places\"\n          WHERE \"place_id\" = NEW.\"place_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_place_reports_place_id_into_oplog\n  AFTER UPDATE ON \"public\".\"place_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_place_reports_place_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'place_report_values', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_place_report_values_primarykey ON \"public\".\"place_report_values\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_place_report_values_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"place_report_value_id\" IS DISTINCT FROM NEW.\"place_report_value_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column place_report_value_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_place_report_values_primarykey\n  BEFORE UPDATE ON \"public\".\"place_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_place_report_values_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_place_report_values_into_oplog ON \"public\".\"place_report_values\";",
      "    CREATE OR REPLACE FUNCTION insert_public_place_report_values_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_report_values';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'place_report_values',\n            'INSERT',\n            json_strip_nulls(json_build_object('place_report_value_id', new.\"place_report_value_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label', new.\"label\", 'place_report_id', new.\"place_report_id\", 'place_report_value_id', new.\"place_report_value_id\", 'unit_id', new.\"unit_id\", 'value_integer', new.\"value_integer\", 'value_numeric', cast(new.\"value_numeric\" as TEXT), 'value_text', new.\"value_text\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_place_report_values_into_oplog\n  AFTER INSERT ON \"public\".\"place_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_place_report_values_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_place_report_values_into_oplog ON \"public\".\"place_report_values\";",
      "    CREATE OR REPLACE FUNCTION update_public_place_report_values_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_report_values';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'place_report_values',\n            'UPDATE',\n            json_strip_nulls(json_build_object('place_report_value_id', new.\"place_report_value_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label', new.\"label\", 'place_report_id', new.\"place_report_id\", 'place_report_value_id', new.\"place_report_value_id\", 'unit_id', new.\"unit_id\", 'value_integer', new.\"value_integer\", 'value_numeric', cast(new.\"value_numeric\" as TEXT), 'value_text', new.\"value_text\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'label', old.\"label\", 'place_report_id', old.\"place_report_id\", 'place_report_value_id', old.\"place_report_value_id\", 'unit_id', old.\"unit_id\", 'value_integer', old.\"value_integer\", 'value_numeric', cast(old.\"value_numeric\" as TEXT), 'value_text', old.\"value_text\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_place_report_values_into_oplog\n  AFTER UPDATE ON \"public\".\"place_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_place_report_values_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_place_report_values_into_oplog ON \"public\".\"place_report_values\";",
      "    CREATE OR REPLACE FUNCTION delete_public_place_report_values_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_report_values';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'place_report_values',\n            'DELETE',\n            json_strip_nulls(json_build_object('place_report_value_id', old.\"place_report_value_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'label', old.\"label\", 'place_report_id', old.\"place_report_id\", 'place_report_value_id', old.\"place_report_value_id\", 'unit_id', old.\"unit_id\", 'value_integer', old.\"value_integer\", 'value_numeric', cast(old.\"value_numeric\" as TEXT), 'value_text', old.\"value_text\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_place_report_values_into_oplog\n  AFTER DELETE ON \"public\".\"place_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_place_report_values_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_place_report_values_account_id_into_oplog ON \"public\".\"place_report_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_place_report_values_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_report_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_place_report_values_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"place_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_place_report_values_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_place_report_values_account_id_into_oplog ON \"public\".\"place_report_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_place_report_values_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_report_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_place_report_values_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"place_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_place_report_values_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_place_report_values_place_report_id_into_oplog ON \"public\".\"place_report_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_place_report_values_place_report_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_report_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'place_reports',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('place_report_id', \"place_report_id\"))),\n            jsonb_build_object('place_report_id', \"place_report_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"place_reports\"\n          WHERE \"place_report_id\" = NEW.\"place_report_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_place_report_values_place_report_id_into_oplog\n  AFTER INSERT ON \"public\".\"place_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_place_report_values_place_report_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_place_report_values_place_report_id_into_oplog ON \"public\".\"place_report_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_place_report_values_place_report_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_report_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'place_reports',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('place_report_id', \"place_report_id\"))),\n            jsonb_build_object('place_report_id', \"place_report_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"place_reports\"\n          WHERE \"place_report_id\" = NEW.\"place_report_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_place_report_values_place_report_id_into_oplog\n  AFTER UPDATE ON \"public\".\"place_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_place_report_values_place_report_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_place_report_values_unit_id_into_oplog ON \"public\".\"place_report_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_place_report_values_unit_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_report_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'units',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('unit_id', \"unit_id\"))),\n            jsonb_build_object('unit_id', \"unit_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"units\"\n          WHERE \"unit_id\" = NEW.\"unit_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_place_report_values_unit_id_into_oplog\n  AFTER INSERT ON \"public\".\"place_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_place_report_values_unit_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_place_report_values_unit_id_into_oplog ON \"public\".\"place_report_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_place_report_values_unit_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_report_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'units',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('unit_id', \"unit_id\"))),\n            jsonb_build_object('unit_id', \"unit_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"units\"\n          WHERE \"unit_id\" = NEW.\"unit_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_place_report_values_unit_id_into_oplog\n  AFTER UPDATE ON \"public\".\"place_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_place_report_values_unit_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'messages', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_messages_primarykey ON \"public\".\"messages\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_messages_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"message_id\" IS DISTINCT FROM NEW.\"message_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column message_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_messages_primarykey\n  BEFORE UPDATE ON \"public\".\"messages\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_messages_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_messages_into_oplog ON \"public\".\"messages\";",
      "    CREATE OR REPLACE FUNCTION insert_public_messages_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'messages';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'messages',\n            'INSERT',\n            json_strip_nulls(json_build_object('message_id', new.\"message_id\")),\n            jsonb_build_object('date', new.\"date\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'message', new.\"message\", 'message_id', new.\"message_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_messages_into_oplog\n  AFTER INSERT ON \"public\".\"messages\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_messages_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_messages_into_oplog ON \"public\".\"messages\";",
      "    CREATE OR REPLACE FUNCTION update_public_messages_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'messages';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'messages',\n            'UPDATE',\n            json_strip_nulls(json_build_object('message_id', new.\"message_id\")),\n            jsonb_build_object('date', new.\"date\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'message', new.\"message\", 'message_id', new.\"message_id\"),\n            jsonb_build_object('date', old.\"date\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'message', old.\"message\", 'message_id', old.\"message_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_messages_into_oplog\n  AFTER UPDATE ON \"public\".\"messages\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_messages_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_messages_into_oplog ON \"public\".\"messages\";",
      "    CREATE OR REPLACE FUNCTION delete_public_messages_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'messages';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'messages',\n            'DELETE',\n            json_strip_nulls(json_build_object('message_id', old.\"message_id\")),\n            NULL,\n            jsonb_build_object('date', old.\"date\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'message', old.\"message\", 'message_id', old.\"message_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_messages_into_oplog\n  AFTER DELETE ON \"public\".\"messages\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_messages_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'user_messages', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_user_messages_primarykey ON \"public\".\"user_messages\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_user_messages_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"user_message_id\" IS DISTINCT FROM NEW.\"user_message_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column user_message_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_user_messages_primarykey\n  BEFORE UPDATE ON \"public\".\"user_messages\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_user_messages_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_user_messages_into_oplog ON \"public\".\"user_messages\";",
      "    CREATE OR REPLACE FUNCTION insert_public_user_messages_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'user_messages';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'user_messages',\n            'INSERT',\n            json_strip_nulls(json_build_object('user_message_id', new.\"user_message_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'message_id', new.\"message_id\", 'read', new.\"read\", 'user_id', new.\"user_id\", 'user_message_id', new.\"user_message_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_user_messages_into_oplog\n  AFTER INSERT ON \"public\".\"user_messages\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_user_messages_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_user_messages_into_oplog ON \"public\".\"user_messages\";",
      "    CREATE OR REPLACE FUNCTION update_public_user_messages_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'user_messages';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'user_messages',\n            'UPDATE',\n            json_strip_nulls(json_build_object('user_message_id', new.\"user_message_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'message_id', new.\"message_id\", 'read', new.\"read\", 'user_id', new.\"user_id\", 'user_message_id', new.\"user_message_id\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'message_id', old.\"message_id\", 'read', old.\"read\", 'user_id', old.\"user_id\", 'user_message_id', old.\"user_message_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_user_messages_into_oplog\n  AFTER UPDATE ON \"public\".\"user_messages\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_user_messages_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_user_messages_into_oplog ON \"public\".\"user_messages\";",
      "    CREATE OR REPLACE FUNCTION delete_public_user_messages_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'user_messages';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'user_messages',\n            'DELETE',\n            json_strip_nulls(json_build_object('user_message_id', old.\"user_message_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'message_id', old.\"message_id\", 'read', old.\"read\", 'user_id', old.\"user_id\", 'user_message_id', old.\"user_message_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_user_messages_into_oplog\n  AFTER DELETE ON \"public\".\"user_messages\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_user_messages_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_user_messages_account_id_into_oplog ON \"public\".\"user_messages\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_user_messages_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'user_messages';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_user_messages_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"user_messages\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_user_messages_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_user_messages_account_id_into_oplog ON \"public\".\"user_messages\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_user_messages_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'user_messages';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_user_messages_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"user_messages\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_user_messages_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_user_messages_message_id_into_oplog ON \"public\".\"user_messages\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_user_messages_message_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'user_messages';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'messages',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('message_id', \"message_id\"))),\n            jsonb_build_object('message_id', \"message_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"messages\"\n          WHERE \"message_id\" = NEW.\"message_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_user_messages_message_id_into_oplog\n  AFTER INSERT ON \"public\".\"user_messages\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_user_messages_message_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_user_messages_message_id_into_oplog ON \"public\".\"user_messages\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_user_messages_message_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'user_messages';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'messages',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('message_id', \"message_id\"))),\n            jsonb_build_object('message_id', \"message_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"messages\"\n          WHERE \"message_id\" = NEW.\"message_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_user_messages_message_id_into_oplog\n  AFTER UPDATE ON \"public\".\"user_messages\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_user_messages_message_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_user_messages_user_id_into_oplog ON \"public\".\"user_messages\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_user_messages_user_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'user_messages';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'users',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('user_id', \"user_id\"))),\n            jsonb_build_object('user_id', \"user_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"users\"\n          WHERE \"user_id\" = NEW.\"user_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_user_messages_user_id_into_oplog\n  AFTER INSERT ON \"public\".\"user_messages\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_user_messages_user_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_user_messages_user_id_into_oplog ON \"public\".\"user_messages\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_user_messages_user_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'user_messages';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'users',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('user_id', \"user_id\"))),\n            jsonb_build_object('user_id', \"user_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"users\"\n          WHERE \"user_id\" = NEW.\"user_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_user_messages_user_id_into_oplog\n  AFTER UPDATE ON \"public\".\"user_messages\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_user_messages_user_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'place_users', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_place_users_primarykey ON \"public\".\"place_users\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_place_users_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"place_user_id\" IS DISTINCT FROM NEW.\"place_user_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column place_user_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_place_users_primarykey\n  BEFORE UPDATE ON \"public\".\"place_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_place_users_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_place_users_into_oplog ON \"public\".\"place_users\";",
      "    CREATE OR REPLACE FUNCTION insert_public_place_users_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_users';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'place_users',\n            'INSERT',\n            json_strip_nulls(json_build_object('place_user_id', new.\"place_user_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label', new.\"label\", 'place_id', new.\"place_id\", 'place_user_id', new.\"place_user_id\", 'role', new.\"role\", 'user_id', new.\"user_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_place_users_into_oplog\n  AFTER INSERT ON \"public\".\"place_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_place_users_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_place_users_into_oplog ON \"public\".\"place_users\";",
      "    CREATE OR REPLACE FUNCTION update_public_place_users_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_users';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'place_users',\n            'UPDATE',\n            json_strip_nulls(json_build_object('place_user_id', new.\"place_user_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label', new.\"label\", 'place_id', new.\"place_id\", 'place_user_id', new.\"place_user_id\", 'role', new.\"role\", 'user_id', new.\"user_id\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'label', old.\"label\", 'place_id', old.\"place_id\", 'place_user_id', old.\"place_user_id\", 'role', old.\"role\", 'user_id', old.\"user_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_place_users_into_oplog\n  AFTER UPDATE ON \"public\".\"place_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_place_users_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_place_users_into_oplog ON \"public\".\"place_users\";",
      "    CREATE OR REPLACE FUNCTION delete_public_place_users_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_users';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'place_users',\n            'DELETE',\n            json_strip_nulls(json_build_object('place_user_id', old.\"place_user_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'label', old.\"label\", 'place_id', old.\"place_id\", 'place_user_id', old.\"place_user_id\", 'role', old.\"role\", 'user_id', old.\"user_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_place_users_into_oplog\n  AFTER DELETE ON \"public\".\"place_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_place_users_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_place_users_account_id_into_oplog ON \"public\".\"place_users\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_place_users_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_users';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_place_users_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"place_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_place_users_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_place_users_account_id_into_oplog ON \"public\".\"place_users\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_place_users_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_users';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_place_users_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"place_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_place_users_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_place_users_place_id_into_oplog ON \"public\".\"place_users\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_place_users_place_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_users';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'places',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('place_id', \"place_id\"))),\n            jsonb_build_object('place_id', \"place_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"places\"\n          WHERE \"place_id\" = NEW.\"place_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_place_users_place_id_into_oplog\n  AFTER INSERT ON \"public\".\"place_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_place_users_place_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_place_users_place_id_into_oplog ON \"public\".\"place_users\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_place_users_place_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_users';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'places',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('place_id', \"place_id\"))),\n            jsonb_build_object('place_id', \"place_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"places\"\n          WHERE \"place_id\" = NEW.\"place_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_place_users_place_id_into_oplog\n  AFTER UPDATE ON \"public\".\"place_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_place_users_place_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_place_users_user_id_into_oplog ON \"public\".\"place_users\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_place_users_user_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_users';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'users',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('user_id', \"user_id\"))),\n            jsonb_build_object('user_id', \"user_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"users\"\n          WHERE \"user_id\" = NEW.\"user_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_place_users_user_id_into_oplog\n  AFTER INSERT ON \"public\".\"place_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_place_users_user_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_place_users_user_id_into_oplog ON \"public\".\"place_users\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_place_users_user_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'place_users';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'users',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('user_id', \"user_id\"))),\n            jsonb_build_object('user_id', \"user_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"users\"\n          WHERE \"user_id\" = NEW.\"user_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_place_users_user_id_into_oplog\n  AFTER UPDATE ON \"public\".\"place_users\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_place_users_user_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'goals', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_goals_primarykey ON \"public\".\"goals\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_goals_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"goal_id\" IS DISTINCT FROM NEW.\"goal_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column goal_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_goals_primarykey\n  BEFORE UPDATE ON \"public\".\"goals\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_goals_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_goals_into_oplog ON \"public\".\"goals\";",
      "    CREATE OR REPLACE FUNCTION insert_public_goals_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goals';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'goals',\n            'INSERT',\n            json_strip_nulls(json_build_object('goal_id', new.\"goal_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'goal_id', new.\"goal_id\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'name', new.\"name\", 'subproject_id', new.\"subproject_id\", 'year', new.\"year\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_goals_into_oplog\n  AFTER INSERT ON \"public\".\"goals\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_goals_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_goals_into_oplog ON \"public\".\"goals\";",
      "    CREATE OR REPLACE FUNCTION update_public_goals_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goals';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'goals',\n            'UPDATE',\n            json_strip_nulls(json_build_object('goal_id', new.\"goal_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'goal_id', new.\"goal_id\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'name', new.\"name\", 'subproject_id', new.\"subproject_id\", 'year', new.\"year\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'goal_id', old.\"goal_id\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'name', old.\"name\", 'subproject_id', old.\"subproject_id\", 'year', old.\"year\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_goals_into_oplog\n  AFTER UPDATE ON \"public\".\"goals\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_goals_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_goals_into_oplog ON \"public\".\"goals\";",
      "    CREATE OR REPLACE FUNCTION delete_public_goals_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goals';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'goals',\n            'DELETE',\n            json_strip_nulls(json_build_object('goal_id', old.\"goal_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'goal_id', old.\"goal_id\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'name', old.\"name\", 'subproject_id', old.\"subproject_id\", 'year', old.\"year\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_goals_into_oplog\n  AFTER DELETE ON \"public\".\"goals\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_goals_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_goals_account_id_into_oplog ON \"public\".\"goals\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_goals_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goals';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_goals_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"goals\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_goals_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_goals_account_id_into_oplog ON \"public\".\"goals\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_goals_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goals';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_goals_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"goals\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_goals_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_goals_subproject_id_into_oplog ON \"public\".\"goals\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_goals_subproject_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goals';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'subprojects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('subproject_id', \"subproject_id\"))),\n            jsonb_build_object('subproject_id', \"subproject_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"subprojects\"\n          WHERE \"subproject_id\" = NEW.\"subproject_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_goals_subproject_id_into_oplog\n  AFTER INSERT ON \"public\".\"goals\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_goals_subproject_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_goals_subproject_id_into_oplog ON \"public\".\"goals\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_goals_subproject_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goals';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'subprojects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('subproject_id', \"subproject_id\"))),\n            jsonb_build_object('subproject_id', \"subproject_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"subprojects\"\n          WHERE \"subproject_id\" = NEW.\"subproject_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_goals_subproject_id_into_oplog\n  AFTER UPDATE ON \"public\".\"goals\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_goals_subproject_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'goal_reports', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_goal_reports_primarykey ON \"public\".\"goal_reports\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_goal_reports_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"goal_report_id\" IS DISTINCT FROM NEW.\"goal_report_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column goal_report_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_goal_reports_primarykey\n  BEFORE UPDATE ON \"public\".\"goal_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_goal_reports_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_goal_reports_into_oplog ON \"public\".\"goal_reports\";",
      "    CREATE OR REPLACE FUNCTION insert_public_goal_reports_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goal_reports';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'goal_reports',\n            'INSERT',\n            json_strip_nulls(json_build_object('goal_report_id', new.\"goal_report_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'goal_id', new.\"goal_id\", 'goal_report_id', new.\"goal_report_id\", 'label', new.\"label\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_goal_reports_into_oplog\n  AFTER INSERT ON \"public\".\"goal_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_goal_reports_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_goal_reports_into_oplog ON \"public\".\"goal_reports\";",
      "    CREATE OR REPLACE FUNCTION update_public_goal_reports_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goal_reports';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'goal_reports',\n            'UPDATE',\n            json_strip_nulls(json_build_object('goal_report_id', new.\"goal_report_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'goal_id', new.\"goal_id\", 'goal_report_id', new.\"goal_report_id\", 'label', new.\"label\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'goal_id', old.\"goal_id\", 'goal_report_id', old.\"goal_report_id\", 'label', old.\"label\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_goal_reports_into_oplog\n  AFTER UPDATE ON \"public\".\"goal_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_goal_reports_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_goal_reports_into_oplog ON \"public\".\"goal_reports\";",
      "    CREATE OR REPLACE FUNCTION delete_public_goal_reports_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goal_reports';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'goal_reports',\n            'DELETE',\n            json_strip_nulls(json_build_object('goal_report_id', old.\"goal_report_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'goal_id', old.\"goal_id\", 'goal_report_id', old.\"goal_report_id\", 'label', old.\"label\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_goal_reports_into_oplog\n  AFTER DELETE ON \"public\".\"goal_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_goal_reports_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_goal_reports_account_id_into_oplog ON \"public\".\"goal_reports\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_goal_reports_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goal_reports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_goal_reports_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"goal_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_goal_reports_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_goal_reports_account_id_into_oplog ON \"public\".\"goal_reports\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_goal_reports_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goal_reports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_goal_reports_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"goal_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_goal_reports_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_goal_reports_goal_id_into_oplog ON \"public\".\"goal_reports\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_goal_reports_goal_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goal_reports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'goals',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('goal_id', \"goal_id\"))),\n            jsonb_build_object('goal_id', \"goal_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"goals\"\n          WHERE \"goal_id\" = NEW.\"goal_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_goal_reports_goal_id_into_oplog\n  AFTER INSERT ON \"public\".\"goal_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_goal_reports_goal_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_goal_reports_goal_id_into_oplog ON \"public\".\"goal_reports\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_goal_reports_goal_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goal_reports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'goals',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('goal_id', \"goal_id\"))),\n            jsonb_build_object('goal_id', \"goal_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"goals\"\n          WHERE \"goal_id\" = NEW.\"goal_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_goal_reports_goal_id_into_oplog\n  AFTER UPDATE ON \"public\".\"goal_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_goal_reports_goal_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'goal_report_values', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_goal_report_values_primarykey ON \"public\".\"goal_report_values\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_goal_report_values_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"goal_report_value_id\" IS DISTINCT FROM NEW.\"goal_report_value_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column goal_report_value_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_goal_report_values_primarykey\n  BEFORE UPDATE ON \"public\".\"goal_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_goal_report_values_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_goal_report_values_into_oplog ON \"public\".\"goal_report_values\";",
      "    CREATE OR REPLACE FUNCTION insert_public_goal_report_values_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goal_report_values';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'goal_report_values',\n            'INSERT',\n            json_strip_nulls(json_build_object('goal_report_value_id', new.\"goal_report_value_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'goal_report_id', new.\"goal_report_id\", 'goal_report_value_id', new.\"goal_report_value_id\", 'label', new.\"label\", 'unit_id', new.\"unit_id\", 'value_integer', new.\"value_integer\", 'value_numeric', cast(new.\"value_numeric\" as TEXT), 'value_text', new.\"value_text\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_goal_report_values_into_oplog\n  AFTER INSERT ON \"public\".\"goal_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_goal_report_values_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_goal_report_values_into_oplog ON \"public\".\"goal_report_values\";",
      "    CREATE OR REPLACE FUNCTION update_public_goal_report_values_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goal_report_values';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'goal_report_values',\n            'UPDATE',\n            json_strip_nulls(json_build_object('goal_report_value_id', new.\"goal_report_value_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'goal_report_id', new.\"goal_report_id\", 'goal_report_value_id', new.\"goal_report_value_id\", 'label', new.\"label\", 'unit_id', new.\"unit_id\", 'value_integer', new.\"value_integer\", 'value_numeric', cast(new.\"value_numeric\" as TEXT), 'value_text', new.\"value_text\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'goal_report_id', old.\"goal_report_id\", 'goal_report_value_id', old.\"goal_report_value_id\", 'label', old.\"label\", 'unit_id', old.\"unit_id\", 'value_integer', old.\"value_integer\", 'value_numeric', cast(old.\"value_numeric\" as TEXT), 'value_text', old.\"value_text\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_goal_report_values_into_oplog\n  AFTER UPDATE ON \"public\".\"goal_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_goal_report_values_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_goal_report_values_into_oplog ON \"public\".\"goal_report_values\";",
      "    CREATE OR REPLACE FUNCTION delete_public_goal_report_values_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goal_report_values';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'goal_report_values',\n            'DELETE',\n            json_strip_nulls(json_build_object('goal_report_value_id', old.\"goal_report_value_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'goal_report_id', old.\"goal_report_id\", 'goal_report_value_id', old.\"goal_report_value_id\", 'label', old.\"label\", 'unit_id', old.\"unit_id\", 'value_integer', old.\"value_integer\", 'value_numeric', cast(old.\"value_numeric\" as TEXT), 'value_text', old.\"value_text\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_goal_report_values_into_oplog\n  AFTER DELETE ON \"public\".\"goal_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_goal_report_values_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_goal_report_values_account_id_into_oplog ON \"public\".\"goal_report_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_goal_report_values_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goal_report_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_goal_report_values_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"goal_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_goal_report_values_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_goal_report_values_account_id_into_oplog ON \"public\".\"goal_report_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_goal_report_values_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goal_report_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_goal_report_values_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"goal_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_goal_report_values_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_goal_report_values_goal_report_id_into_oplog ON \"public\".\"goal_report_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_goal_report_values_goal_report_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goal_report_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'goal_reports',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('goal_report_id', \"goal_report_id\"))),\n            jsonb_build_object('goal_report_id', \"goal_report_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"goal_reports\"\n          WHERE \"goal_report_id\" = NEW.\"goal_report_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_goal_report_values_goal_report_id_into_oplog\n  AFTER INSERT ON \"public\".\"goal_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_goal_report_values_goal_report_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_goal_report_values_goal_report_id_into_oplog ON \"public\".\"goal_report_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_goal_report_values_goal_report_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goal_report_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'goal_reports',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('goal_report_id', \"goal_report_id\"))),\n            jsonb_build_object('goal_report_id', \"goal_report_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"goal_reports\"\n          WHERE \"goal_report_id\" = NEW.\"goal_report_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_goal_report_values_goal_report_id_into_oplog\n  AFTER UPDATE ON \"public\".\"goal_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_goal_report_values_goal_report_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_goal_report_values_unit_id_into_oplog ON \"public\".\"goal_report_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_goal_report_values_unit_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goal_report_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'units',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('unit_id', \"unit_id\"))),\n            jsonb_build_object('unit_id', \"unit_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"units\"\n          WHERE \"unit_id\" = NEW.\"unit_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_goal_report_values_unit_id_into_oplog\n  AFTER INSERT ON \"public\".\"goal_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_goal_report_values_unit_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_goal_report_values_unit_id_into_oplog ON \"public\".\"goal_report_values\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_goal_report_values_unit_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'goal_report_values';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'units',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('unit_id', \"unit_id\"))),\n            jsonb_build_object('unit_id', \"unit_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"units\"\n          WHERE \"unit_id\" = NEW.\"unit_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_goal_report_values_unit_id_into_oplog\n  AFTER UPDATE ON \"public\".\"goal_report_values\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_goal_report_values_unit_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'subproject_reports', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_subproject_reports_primarykey ON \"public\".\"subproject_reports\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_subproject_reports_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"subproject_report_id\" IS DISTINCT FROM NEW.\"subproject_report_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column subproject_report_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_subproject_reports_primarykey\n  BEFORE UPDATE ON \"public\".\"subproject_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_subproject_reports_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_subproject_reports_into_oplog ON \"public\".\"subproject_reports\";",
      "    CREATE OR REPLACE FUNCTION insert_public_subproject_reports_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_reports';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'subproject_reports',\n            'INSERT',\n            json_strip_nulls(json_build_object('subproject_report_id', new.\"subproject_report_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'subproject_id', new.\"subproject_id\", 'subproject_report_id', new.\"subproject_report_id\", 'year', new.\"year\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_subproject_reports_into_oplog\n  AFTER INSERT ON \"public\".\"subproject_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_subproject_reports_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_subproject_reports_into_oplog ON \"public\".\"subproject_reports\";",
      "    CREATE OR REPLACE FUNCTION update_public_subproject_reports_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_reports';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'subproject_reports',\n            'UPDATE',\n            json_strip_nulls(json_build_object('subproject_report_id', new.\"subproject_report_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'subproject_id', new.\"subproject_id\", 'subproject_report_id', new.\"subproject_report_id\", 'year', new.\"year\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'subproject_id', old.\"subproject_id\", 'subproject_report_id', old.\"subproject_report_id\", 'year', old.\"year\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_subproject_reports_into_oplog\n  AFTER UPDATE ON \"public\".\"subproject_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_subproject_reports_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_subproject_reports_into_oplog ON \"public\".\"subproject_reports\";",
      "    CREATE OR REPLACE FUNCTION delete_public_subproject_reports_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_reports';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'subproject_reports',\n            'DELETE',\n            json_strip_nulls(json_build_object('subproject_report_id', old.\"subproject_report_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'subproject_id', old.\"subproject_id\", 'subproject_report_id', old.\"subproject_report_id\", 'year', old.\"year\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_subproject_reports_into_oplog\n  AFTER DELETE ON \"public\".\"subproject_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_subproject_reports_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_subproject_reports_account_id_into_oplog ON \"public\".\"subproject_reports\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_subproject_reports_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_reports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_subproject_reports_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"subproject_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_subproject_reports_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_subproject_reports_account_id_into_oplog ON \"public\".\"subproject_reports\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_subproject_reports_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_reports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_subproject_reports_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"subproject_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_subproject_reports_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_subproject_reports_subproject_id_into_oplog ON \"public\".\"subproject_reports\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_subproject_reports_subproject_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_reports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'subprojects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('subproject_id', \"subproject_id\"))),\n            jsonb_build_object('subproject_id', \"subproject_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"subprojects\"\n          WHERE \"subproject_id\" = NEW.\"subproject_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_subproject_reports_subproject_id_into_oplog\n  AFTER INSERT ON \"public\".\"subproject_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_subproject_reports_subproject_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_subproject_reports_subproject_id_into_oplog ON \"public\".\"subproject_reports\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_subproject_reports_subproject_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'subproject_reports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'subprojects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('subproject_id', \"subproject_id\"))),\n            jsonb_build_object('subproject_id', \"subproject_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"subprojects\"\n          WHERE \"subproject_id\" = NEW.\"subproject_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_subproject_reports_subproject_id_into_oplog\n  AFTER UPDATE ON \"public\".\"subproject_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_subproject_reports_subproject_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'project_reports', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_project_reports_primarykey ON \"public\".\"project_reports\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_project_reports_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"project_report_id\" IS DISTINCT FROM NEW.\"project_report_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column project_report_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_project_reports_primarykey\n  BEFORE UPDATE ON \"public\".\"project_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_project_reports_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_project_reports_into_oplog ON \"public\".\"project_reports\";",
      "    CREATE OR REPLACE FUNCTION insert_public_project_reports_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_reports';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'project_reports',\n            'INSERT',\n            json_strip_nulls(json_build_object('project_report_id', new.\"project_report_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'project_id', new.\"project_id\", 'project_report_id', new.\"project_report_id\", 'year', new.\"year\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_project_reports_into_oplog\n  AFTER INSERT ON \"public\".\"project_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_project_reports_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_project_reports_into_oplog ON \"public\".\"project_reports\";",
      "    CREATE OR REPLACE FUNCTION update_public_project_reports_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_reports';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'project_reports',\n            'UPDATE',\n            json_strip_nulls(json_build_object('project_report_id', new.\"project_report_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'project_id', new.\"project_id\", 'project_report_id', new.\"project_report_id\", 'year', new.\"year\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'project_id', old.\"project_id\", 'project_report_id', old.\"project_report_id\", 'year', old.\"year\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_project_reports_into_oplog\n  AFTER UPDATE ON \"public\".\"project_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_project_reports_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_project_reports_into_oplog ON \"public\".\"project_reports\";",
      "    CREATE OR REPLACE FUNCTION delete_public_project_reports_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_reports';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'project_reports',\n            'DELETE',\n            json_strip_nulls(json_build_object('project_report_id', old.\"project_report_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'project_id', old.\"project_id\", 'project_report_id', old.\"project_report_id\", 'year', old.\"year\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_project_reports_into_oplog\n  AFTER DELETE ON \"public\".\"project_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_project_reports_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_project_reports_account_id_into_oplog ON \"public\".\"project_reports\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_project_reports_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_reports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_project_reports_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"project_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_project_reports_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_project_reports_account_id_into_oplog ON \"public\".\"project_reports\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_project_reports_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_reports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_project_reports_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"project_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_project_reports_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_project_reports_project_id_into_oplog ON \"public\".\"project_reports\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_project_reports_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_reports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_project_reports_project_id_into_oplog\n  AFTER INSERT ON \"public\".\"project_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_project_reports_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_project_reports_project_id_into_oplog ON \"public\".\"project_reports\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_project_reports_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_reports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_project_reports_project_id_into_oplog\n  AFTER UPDATE ON \"public\".\"project_reports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_project_reports_project_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'files', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_files_primarykey ON \"public\".\"files\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_files_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"file_id\" IS DISTINCT FROM NEW.\"file_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column file_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_files_primarykey\n  BEFORE UPDATE ON \"public\".\"files\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_files_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_files_into_oplog ON \"public\".\"files\";",
      "    CREATE OR REPLACE FUNCTION insert_public_files_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'files';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'files',\n            'INSERT',\n            json_strip_nulls(json_build_object('file_id', new.\"file_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'action_id', new.\"action_id\", 'check_id', new.\"check_id\", 'data', new.\"data\", 'file_id', new.\"file_id\", 'height', new.\"height\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'mimetype', new.\"mimetype\", 'name', new.\"name\", 'place_id', new.\"place_id\", 'preview_uuid', new.\"preview_uuid\", 'project_id', new.\"project_id\", 'size', cast(new.\"size\" as TEXT), 'subproject_id', new.\"subproject_id\", 'url', new.\"url\", 'uuid', new.\"uuid\", 'width', new.\"width\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_files_into_oplog\n  AFTER INSERT ON \"public\".\"files\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_files_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_files_into_oplog ON \"public\".\"files\";",
      "    CREATE OR REPLACE FUNCTION update_public_files_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'files';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'files',\n            'UPDATE',\n            json_strip_nulls(json_build_object('file_id', new.\"file_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'action_id', new.\"action_id\", 'check_id', new.\"check_id\", 'data', new.\"data\", 'file_id', new.\"file_id\", 'height', new.\"height\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'mimetype', new.\"mimetype\", 'name', new.\"name\", 'place_id', new.\"place_id\", 'preview_uuid', new.\"preview_uuid\", 'project_id', new.\"project_id\", 'size', cast(new.\"size\" as TEXT), 'subproject_id', new.\"subproject_id\", 'url', new.\"url\", 'uuid', new.\"uuid\", 'width', new.\"width\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'action_id', old.\"action_id\", 'check_id', old.\"check_id\", 'data', old.\"data\", 'file_id', old.\"file_id\", 'height', old.\"height\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'mimetype', old.\"mimetype\", 'name', old.\"name\", 'place_id', old.\"place_id\", 'preview_uuid', old.\"preview_uuid\", 'project_id', old.\"project_id\", 'size', cast(old.\"size\" as TEXT), 'subproject_id', old.\"subproject_id\", 'url', old.\"url\", 'uuid', old.\"uuid\", 'width', old.\"width\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_files_into_oplog\n  AFTER UPDATE ON \"public\".\"files\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_files_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_files_into_oplog ON \"public\".\"files\";",
      "    CREATE OR REPLACE FUNCTION delete_public_files_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'files';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'files',\n            'DELETE',\n            json_strip_nulls(json_build_object('file_id', old.\"file_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'action_id', old.\"action_id\", 'check_id', old.\"check_id\", 'data', old.\"data\", 'file_id', old.\"file_id\", 'height', old.\"height\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'mimetype', old.\"mimetype\", 'name', old.\"name\", 'place_id', old.\"place_id\", 'preview_uuid', old.\"preview_uuid\", 'project_id', old.\"project_id\", 'size', cast(old.\"size\" as TEXT), 'subproject_id', old.\"subproject_id\", 'url', old.\"url\", 'uuid', old.\"uuid\", 'width', old.\"width\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_files_into_oplog\n  AFTER DELETE ON \"public\".\"files\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_files_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_files_account_id_into_oplog ON \"public\".\"files\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_files_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'files';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_files_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"files\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_files_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_files_account_id_into_oplog ON \"public\".\"files\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_files_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'files';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_files_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"files\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_files_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_files_action_id_into_oplog ON \"public\".\"files\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_files_action_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'files';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'actions',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('action_id', \"action_id\"))),\n            jsonb_build_object('action_id', \"action_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"actions\"\n          WHERE \"action_id\" = NEW.\"action_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_files_action_id_into_oplog\n  AFTER INSERT ON \"public\".\"files\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_files_action_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_files_action_id_into_oplog ON \"public\".\"files\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_files_action_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'files';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'actions',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('action_id', \"action_id\"))),\n            jsonb_build_object('action_id', \"action_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"actions\"\n          WHERE \"action_id\" = NEW.\"action_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_files_action_id_into_oplog\n  AFTER UPDATE ON \"public\".\"files\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_files_action_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_files_check_id_into_oplog ON \"public\".\"files\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_files_check_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'files';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'checks',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('check_id', \"check_id\"))),\n            jsonb_build_object('check_id', \"check_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"checks\"\n          WHERE \"check_id\" = NEW.\"check_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_files_check_id_into_oplog\n  AFTER INSERT ON \"public\".\"files\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_files_check_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_files_check_id_into_oplog ON \"public\".\"files\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_files_check_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'files';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'checks',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('check_id', \"check_id\"))),\n            jsonb_build_object('check_id', \"check_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"checks\"\n          WHERE \"check_id\" = NEW.\"check_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_files_check_id_into_oplog\n  AFTER UPDATE ON \"public\".\"files\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_files_check_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_files_place_id_into_oplog ON \"public\".\"files\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_files_place_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'files';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'places',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('place_id', \"place_id\"))),\n            jsonb_build_object('place_id', \"place_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"places\"\n          WHERE \"place_id\" = NEW.\"place_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_files_place_id_into_oplog\n  AFTER INSERT ON \"public\".\"files\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_files_place_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_files_place_id_into_oplog ON \"public\".\"files\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_files_place_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'files';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'places',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('place_id', \"place_id\"))),\n            jsonb_build_object('place_id', \"place_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"places\"\n          WHERE \"place_id\" = NEW.\"place_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_files_place_id_into_oplog\n  AFTER UPDATE ON \"public\".\"files\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_files_place_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_files_project_id_into_oplog ON \"public\".\"files\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_files_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'files';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_files_project_id_into_oplog\n  AFTER INSERT ON \"public\".\"files\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_files_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_files_project_id_into_oplog ON \"public\".\"files\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_files_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'files';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_files_project_id_into_oplog\n  AFTER UPDATE ON \"public\".\"files\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_files_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_files_subproject_id_into_oplog ON \"public\".\"files\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_files_subproject_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'files';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'subprojects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('subproject_id', \"subproject_id\"))),\n            jsonb_build_object('subproject_id', \"subproject_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"subprojects\"\n          WHERE \"subproject_id\" = NEW.\"subproject_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_files_subproject_id_into_oplog\n  AFTER INSERT ON \"public\".\"files\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_files_subproject_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_files_subproject_id_into_oplog ON \"public\".\"files\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_files_subproject_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'files';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'subprojects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('subproject_id', \"subproject_id\"))),\n            jsonb_build_object('subproject_id', \"subproject_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"subprojects\"\n          WHERE \"subproject_id\" = NEW.\"subproject_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_files_subproject_id_into_oplog\n  AFTER UPDATE ON \"public\".\"files\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_files_subproject_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'persons', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_persons_primarykey ON \"public\".\"persons\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_persons_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"person_id\" IS DISTINCT FROM NEW.\"person_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column person_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_persons_primarykey\n  BEFORE UPDATE ON \"public\".\"persons\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_persons_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_persons_into_oplog ON \"public\".\"persons\";",
      "    CREATE OR REPLACE FUNCTION insert_public_persons_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'persons';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'persons',\n            'INSERT',\n            json_strip_nulls(json_build_object('person_id', new.\"person_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'email', new.\"email\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'person_id', new.\"person_id\", 'project_id', new.\"project_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_persons_into_oplog\n  AFTER INSERT ON \"public\".\"persons\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_persons_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_persons_into_oplog ON \"public\".\"persons\";",
      "    CREATE OR REPLACE FUNCTION update_public_persons_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'persons';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'persons',\n            'UPDATE',\n            json_strip_nulls(json_build_object('person_id', new.\"person_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'data', new.\"data\", 'email', new.\"email\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'person_id', new.\"person_id\", 'project_id', new.\"project_id\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'email', old.\"email\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'person_id', old.\"person_id\", 'project_id', old.\"project_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_persons_into_oplog\n  AFTER UPDATE ON \"public\".\"persons\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_persons_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_persons_into_oplog ON \"public\".\"persons\";",
      "    CREATE OR REPLACE FUNCTION delete_public_persons_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'persons';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'persons',\n            'DELETE',\n            json_strip_nulls(json_build_object('person_id', old.\"person_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'data', old.\"data\", 'email', old.\"email\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'person_id', old.\"person_id\", 'project_id', old.\"project_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_persons_into_oplog\n  AFTER DELETE ON \"public\".\"persons\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_persons_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_persons_account_id_into_oplog ON \"public\".\"persons\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_persons_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'persons';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_persons_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"persons\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_persons_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_persons_account_id_into_oplog ON \"public\".\"persons\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_persons_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'persons';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_persons_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"persons\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_persons_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_persons_project_id_into_oplog ON \"public\".\"persons\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_persons_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'persons';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_persons_project_id_into_oplog\n  AFTER INSERT ON \"public\".\"persons\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_persons_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_persons_project_id_into_oplog ON \"public\".\"persons\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_persons_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'persons';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_persons_project_id_into_oplog\n  AFTER UPDATE ON \"public\".\"persons\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_persons_project_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'field_types', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_field_types_primarykey ON \"public\".\"field_types\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_field_types_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"field_type_id\" IS DISTINCT FROM NEW.\"field_type_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column field_type_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_field_types_primarykey\n  BEFORE UPDATE ON \"public\".\"field_types\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_field_types_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_field_types_into_oplog ON \"public\".\"field_types\";",
      "    CREATE OR REPLACE FUNCTION insert_public_field_types_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'field_types';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'field_types',\n            'INSERT',\n            json_strip_nulls(json_build_object('field_type_id', new.\"field_type_id\")),\n            jsonb_build_object('comment', new.\"comment\", 'field_type_id', new.\"field_type_id\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'name', new.\"name\", 'sort', new.\"sort\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_field_types_into_oplog\n  AFTER INSERT ON \"public\".\"field_types\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_field_types_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_field_types_into_oplog ON \"public\".\"field_types\";",
      "    CREATE OR REPLACE FUNCTION update_public_field_types_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'field_types';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'field_types',\n            'UPDATE',\n            json_strip_nulls(json_build_object('field_type_id', new.\"field_type_id\")),\n            jsonb_build_object('comment', new.\"comment\", 'field_type_id', new.\"field_type_id\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'name', new.\"name\", 'sort', new.\"sort\"),\n            jsonb_build_object('comment', old.\"comment\", 'field_type_id', old.\"field_type_id\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'name', old.\"name\", 'sort', old.\"sort\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_field_types_into_oplog\n  AFTER UPDATE ON \"public\".\"field_types\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_field_types_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_field_types_into_oplog ON \"public\".\"field_types\";",
      "    CREATE OR REPLACE FUNCTION delete_public_field_types_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'field_types';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'field_types',\n            'DELETE',\n            json_strip_nulls(json_build_object('field_type_id', old.\"field_type_id\")),\n            NULL,\n            jsonb_build_object('comment', old.\"comment\", 'field_type_id', old.\"field_type_id\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'name', old.\"name\", 'sort', old.\"sort\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_field_types_into_oplog\n  AFTER DELETE ON \"public\".\"field_types\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_field_types_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'widget_types', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_widget_types_primarykey ON \"public\".\"widget_types\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_widget_types_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"widget_type_id\" IS DISTINCT FROM NEW.\"widget_type_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column widget_type_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_widget_types_primarykey\n  BEFORE UPDATE ON \"public\".\"widget_types\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_widget_types_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_widget_types_into_oplog ON \"public\".\"widget_types\";",
      "    CREATE OR REPLACE FUNCTION insert_public_widget_types_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'widget_types';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'widget_types',\n            'INSERT',\n            json_strip_nulls(json_build_object('widget_type_id', new.\"widget_type_id\")),\n            jsonb_build_object('comment', new.\"comment\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'name', new.\"name\", 'needs_list', new.\"needs_list\", 'sort', new.\"sort\", 'widget_type_id', new.\"widget_type_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_widget_types_into_oplog\n  AFTER INSERT ON \"public\".\"widget_types\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_widget_types_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_widget_types_into_oplog ON \"public\".\"widget_types\";",
      "    CREATE OR REPLACE FUNCTION update_public_widget_types_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'widget_types';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'widget_types',\n            'UPDATE',\n            json_strip_nulls(json_build_object('widget_type_id', new.\"widget_type_id\")),\n            jsonb_build_object('comment', new.\"comment\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'name', new.\"name\", 'needs_list', new.\"needs_list\", 'sort', new.\"sort\", 'widget_type_id', new.\"widget_type_id\"),\n            jsonb_build_object('comment', old.\"comment\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'name', old.\"name\", 'needs_list', old.\"needs_list\", 'sort', old.\"sort\", 'widget_type_id', old.\"widget_type_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_widget_types_into_oplog\n  AFTER UPDATE ON \"public\".\"widget_types\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_widget_types_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_widget_types_into_oplog ON \"public\".\"widget_types\";",
      "    CREATE OR REPLACE FUNCTION delete_public_widget_types_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'widget_types';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'widget_types',\n            'DELETE',\n            json_strip_nulls(json_build_object('widget_type_id', old.\"widget_type_id\")),\n            NULL,\n            jsonb_build_object('comment', old.\"comment\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'name', old.\"name\", 'needs_list', old.\"needs_list\", 'sort', old.\"sort\", 'widget_type_id', old.\"widget_type_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_widget_types_into_oplog\n  AFTER DELETE ON \"public\".\"widget_types\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_widget_types_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'widgets_for_fields', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_widgets_for_fields_primarykey ON \"public\".\"widgets_for_fields\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_widgets_for_fields_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"widget_for_field_id\" IS DISTINCT FROM NEW.\"widget_for_field_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column widget_for_field_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_widgets_for_fields_primarykey\n  BEFORE UPDATE ON \"public\".\"widgets_for_fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_widgets_for_fields_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_widgets_for_fields_into_oplog ON \"public\".\"widgets_for_fields\";",
      "    CREATE OR REPLACE FUNCTION insert_public_widgets_for_fields_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'widgets_for_fields';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'widgets_for_fields',\n            'INSERT',\n            json_strip_nulls(json_build_object('widget_for_field_id', new.\"widget_for_field_id\")),\n            jsonb_build_object('field_type_id', new.\"field_type_id\", 'label', new.\"label\", 'widget_for_field_id', new.\"widget_for_field_id\", 'widget_type_id', new.\"widget_type_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_widgets_for_fields_into_oplog\n  AFTER INSERT ON \"public\".\"widgets_for_fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_widgets_for_fields_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_widgets_for_fields_into_oplog ON \"public\".\"widgets_for_fields\";",
      "    CREATE OR REPLACE FUNCTION update_public_widgets_for_fields_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'widgets_for_fields';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'widgets_for_fields',\n            'UPDATE',\n            json_strip_nulls(json_build_object('widget_for_field_id', new.\"widget_for_field_id\")),\n            jsonb_build_object('field_type_id', new.\"field_type_id\", 'label', new.\"label\", 'widget_for_field_id', new.\"widget_for_field_id\", 'widget_type_id', new.\"widget_type_id\"),\n            jsonb_build_object('field_type_id', old.\"field_type_id\", 'label', old.\"label\", 'widget_for_field_id', old.\"widget_for_field_id\", 'widget_type_id', old.\"widget_type_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_widgets_for_fields_into_oplog\n  AFTER UPDATE ON \"public\".\"widgets_for_fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_widgets_for_fields_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_widgets_for_fields_into_oplog ON \"public\".\"widgets_for_fields\";",
      "    CREATE OR REPLACE FUNCTION delete_public_widgets_for_fields_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'widgets_for_fields';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'widgets_for_fields',\n            'DELETE',\n            json_strip_nulls(json_build_object('widget_for_field_id', old.\"widget_for_field_id\")),\n            NULL,\n            jsonb_build_object('field_type_id', old.\"field_type_id\", 'label', old.\"label\", 'widget_for_field_id', old.\"widget_for_field_id\", 'widget_type_id', old.\"widget_type_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_widgets_for_fields_into_oplog\n  AFTER DELETE ON \"public\".\"widgets_for_fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_widgets_for_fields_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_widgets_for_fields_field_type_id_into_oplog ON \"public\".\"widgets_for_fields\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_widgets_for_fields_field_type_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'widgets_for_fields';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'field_types',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('field_type_id', \"field_type_id\"))),\n            jsonb_build_object('field_type_id', \"field_type_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"field_types\"\n          WHERE \"field_type_id\" = NEW.\"field_type_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_widgets_for_fields_field_type_id_into_oplog\n  AFTER INSERT ON \"public\".\"widgets_for_fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_widgets_for_fields_field_type_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_widgets_for_fields_field_type_id_into_oplog ON \"public\".\"widgets_for_fields\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_widgets_for_fields_field_type_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'widgets_for_fields';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'field_types',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('field_type_id', \"field_type_id\"))),\n            jsonb_build_object('field_type_id', \"field_type_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"field_types\"\n          WHERE \"field_type_id\" = NEW.\"field_type_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_widgets_for_fields_field_type_id_into_oplog\n  AFTER UPDATE ON \"public\".\"widgets_for_fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_widgets_for_fields_field_type_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_widgets_for_fields_widget_type_id_into_oplog ON \"public\".\"widgets_for_fields\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_widgets_for_fields_widget_type_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'widgets_for_fields';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'widget_types',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('widget_type_id', \"widget_type_id\"))),\n            jsonb_build_object('widget_type_id', \"widget_type_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"widget_types\"\n          WHERE \"widget_type_id\" = NEW.\"widget_type_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_widgets_for_fields_widget_type_id_into_oplog\n  AFTER INSERT ON \"public\".\"widgets_for_fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_widgets_for_fields_widget_type_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_widgets_for_fields_widget_type_id_into_oplog ON \"public\".\"widgets_for_fields\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_widgets_for_fields_widget_type_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'widgets_for_fields';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'widget_types',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('widget_type_id', \"widget_type_id\"))),\n            jsonb_build_object('widget_type_id', \"widget_type_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"widget_types\"\n          WHERE \"widget_type_id\" = NEW.\"widget_type_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_widgets_for_fields_widget_type_id_into_oplog\n  AFTER UPDATE ON \"public\".\"widgets_for_fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_widgets_for_fields_widget_type_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'fields', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_fields_primarykey ON \"public\".\"fields\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_fields_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"field_id\" IS DISTINCT FROM NEW.\"field_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column field_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_fields_primarykey\n  BEFORE UPDATE ON \"public\".\"fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_fields_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_fields_into_oplog ON \"public\".\"fields\";",
      "    CREATE OR REPLACE FUNCTION insert_public_fields_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'fields';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'fields',\n            'INSERT',\n            json_strip_nulls(json_build_object('field_id', new.\"field_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'field_id', new.\"field_id\", 'field_label', new.\"field_label\", 'field_type_id', new.\"field_type_id\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'level', new.\"level\", 'list_id', new.\"list_id\", 'name', new.\"name\", 'obsolete', new.\"obsolete\", 'preset', new.\"preset\", 'project_id', new.\"project_id\", 'sort_index', new.\"sort_index\", 'table_name', new.\"table_name\", 'widget_type_id', new.\"widget_type_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_fields_into_oplog\n  AFTER INSERT ON \"public\".\"fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_fields_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_fields_into_oplog ON \"public\".\"fields\";",
      "    CREATE OR REPLACE FUNCTION update_public_fields_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'fields';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'fields',\n            'UPDATE',\n            json_strip_nulls(json_build_object('field_id', new.\"field_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'field_id', new.\"field_id\", 'field_label', new.\"field_label\", 'field_type_id', new.\"field_type_id\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'level', new.\"level\", 'list_id', new.\"list_id\", 'name', new.\"name\", 'obsolete', new.\"obsolete\", 'preset', new.\"preset\", 'project_id', new.\"project_id\", 'sort_index', new.\"sort_index\", 'table_name', new.\"table_name\", 'widget_type_id', new.\"widget_type_id\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'field_id', old.\"field_id\", 'field_label', old.\"field_label\", 'field_type_id', old.\"field_type_id\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'level', old.\"level\", 'list_id', old.\"list_id\", 'name', old.\"name\", 'obsolete', old.\"obsolete\", 'preset', old.\"preset\", 'project_id', old.\"project_id\", 'sort_index', old.\"sort_index\", 'table_name', old.\"table_name\", 'widget_type_id', old.\"widget_type_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_fields_into_oplog\n  AFTER UPDATE ON \"public\".\"fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_fields_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_fields_into_oplog ON \"public\".\"fields\";",
      "    CREATE OR REPLACE FUNCTION delete_public_fields_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'fields';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'fields',\n            'DELETE',\n            json_strip_nulls(json_build_object('field_id', old.\"field_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'field_id', old.\"field_id\", 'field_label', old.\"field_label\", 'field_type_id', old.\"field_type_id\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'level', old.\"level\", 'list_id', old.\"list_id\", 'name', old.\"name\", 'obsolete', old.\"obsolete\", 'preset', old.\"preset\", 'project_id', old.\"project_id\", 'sort_index', old.\"sort_index\", 'table_name', old.\"table_name\", 'widget_type_id', old.\"widget_type_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_fields_into_oplog\n  AFTER DELETE ON \"public\".\"fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_fields_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_fields_account_id_into_oplog ON \"public\".\"fields\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_fields_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'fields';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_fields_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_fields_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_fields_account_id_into_oplog ON \"public\".\"fields\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_fields_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'fields';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_fields_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_fields_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_fields_field_type_id_into_oplog ON \"public\".\"fields\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_fields_field_type_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'fields';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'field_types',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('field_type_id', \"field_type_id\"))),\n            jsonb_build_object('field_type_id', \"field_type_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"field_types\"\n          WHERE \"field_type_id\" = NEW.\"field_type_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_fields_field_type_id_into_oplog\n  AFTER INSERT ON \"public\".\"fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_fields_field_type_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_fields_field_type_id_into_oplog ON \"public\".\"fields\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_fields_field_type_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'fields';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'field_types',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('field_type_id', \"field_type_id\"))),\n            jsonb_build_object('field_type_id', \"field_type_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"field_types\"\n          WHERE \"field_type_id\" = NEW.\"field_type_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_fields_field_type_id_into_oplog\n  AFTER UPDATE ON \"public\".\"fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_fields_field_type_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_fields_list_id_into_oplog ON \"public\".\"fields\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_fields_list_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'fields';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'lists',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('list_id', \"list_id\"))),\n            jsonb_build_object('list_id', \"list_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"lists\"\n          WHERE \"list_id\" = NEW.\"list_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_fields_list_id_into_oplog\n  AFTER INSERT ON \"public\".\"fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_fields_list_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_fields_list_id_into_oplog ON \"public\".\"fields\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_fields_list_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'fields';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'lists',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('list_id', \"list_id\"))),\n            jsonb_build_object('list_id', \"list_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"lists\"\n          WHERE \"list_id\" = NEW.\"list_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_fields_list_id_into_oplog\n  AFTER UPDATE ON \"public\".\"fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_fields_list_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_fields_project_id_into_oplog ON \"public\".\"fields\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_fields_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'fields';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_fields_project_id_into_oplog\n  AFTER INSERT ON \"public\".\"fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_fields_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_fields_project_id_into_oplog ON \"public\".\"fields\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_fields_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'fields';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_fields_project_id_into_oplog\n  AFTER UPDATE ON \"public\".\"fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_fields_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_fields_widget_type_id_into_oplog ON \"public\".\"fields\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_fields_widget_type_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'fields';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'widget_types',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('widget_type_id', \"widget_type_id\"))),\n            jsonb_build_object('widget_type_id', \"widget_type_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"widget_types\"\n          WHERE \"widget_type_id\" = NEW.\"widget_type_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_fields_widget_type_id_into_oplog\n  AFTER INSERT ON \"public\".\"fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_fields_widget_type_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_fields_widget_type_id_into_oplog ON \"public\".\"fields\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_fields_widget_type_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'fields';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'widget_types',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('widget_type_id', \"widget_type_id\"))),\n            jsonb_build_object('widget_type_id', \"widget_type_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"widget_types\"\n          WHERE \"widget_type_id\" = NEW.\"widget_type_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_fields_widget_type_id_into_oplog\n  AFTER UPDATE ON \"public\".\"fields\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_fields_widget_type_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'occurrence_imports', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_occurrence_imports_primarykey ON \"public\".\"occurrence_imports\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_occurrence_imports_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"occurrence_import_id\" IS DISTINCT FROM NEW.\"occurrence_import_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column occurrence_import_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_occurrence_imports_primarykey\n  BEFORE UPDATE ON \"public\".\"occurrence_imports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_occurrence_imports_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_occurrence_imports_into_oplog ON \"public\".\"occurrence_imports\";",
      "    CREATE OR REPLACE FUNCTION insert_public_occurrence_imports_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'occurrence_imports';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'occurrence_imports',\n            'INSERT',\n            json_strip_nulls(json_build_object('occurrence_import_id', new.\"occurrence_import_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'attribution', new.\"attribution\", 'created_time', new.\"created_time\", 'crs', new.\"crs\", 'download_from_gbif', new.\"download_from_gbif\", 'gbif_download_key', new.\"gbif_download_key\", 'gbif_error', new.\"gbif_error\", 'gbif_filters', new.\"gbif_filters\", 'geojson_geometry_field', new.\"geojson_geometry_field\", 'geometry_method', new.\"geometry_method\", 'id_field', new.\"id_field\", 'inserted_count', new.\"inserted_count\", 'label_creation', new.\"label_creation\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'name', new.\"name\", 'occurrence_import_id', new.\"occurrence_import_id\", 'previous_import', new.\"previous_import\", 'previous_import_operation', new.\"previous_import_operation\", 'subproject_id', new.\"subproject_id\", 'x_coordinate_field', new.\"x_coordinate_field\", 'y_coordinate_field', new.\"y_coordinate_field\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_occurrence_imports_into_oplog\n  AFTER INSERT ON \"public\".\"occurrence_imports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_occurrence_imports_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_occurrence_imports_into_oplog ON \"public\".\"occurrence_imports\";",
      "    CREATE OR REPLACE FUNCTION update_public_occurrence_imports_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'occurrence_imports';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'occurrence_imports',\n            'UPDATE',\n            json_strip_nulls(json_build_object('occurrence_import_id', new.\"occurrence_import_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'attribution', new.\"attribution\", 'created_time', new.\"created_time\", 'crs', new.\"crs\", 'download_from_gbif', new.\"download_from_gbif\", 'gbif_download_key', new.\"gbif_download_key\", 'gbif_error', new.\"gbif_error\", 'gbif_filters', new.\"gbif_filters\", 'geojson_geometry_field', new.\"geojson_geometry_field\", 'geometry_method', new.\"geometry_method\", 'id_field', new.\"id_field\", 'inserted_count', new.\"inserted_count\", 'label_creation', new.\"label_creation\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'name', new.\"name\", 'occurrence_import_id', new.\"occurrence_import_id\", 'previous_import', new.\"previous_import\", 'previous_import_operation', new.\"previous_import_operation\", 'subproject_id', new.\"subproject_id\", 'x_coordinate_field', new.\"x_coordinate_field\", 'y_coordinate_field', new.\"y_coordinate_field\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'attribution', old.\"attribution\", 'created_time', old.\"created_time\", 'crs', old.\"crs\", 'download_from_gbif', old.\"download_from_gbif\", 'gbif_download_key', old.\"gbif_download_key\", 'gbif_error', old.\"gbif_error\", 'gbif_filters', old.\"gbif_filters\", 'geojson_geometry_field', old.\"geojson_geometry_field\", 'geometry_method', old.\"geometry_method\", 'id_field', old.\"id_field\", 'inserted_count', old.\"inserted_count\", 'label_creation', old.\"label_creation\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'name', old.\"name\", 'occurrence_import_id', old.\"occurrence_import_id\", 'previous_import', old.\"previous_import\", 'previous_import_operation', old.\"previous_import_operation\", 'subproject_id', old.\"subproject_id\", 'x_coordinate_field', old.\"x_coordinate_field\", 'y_coordinate_field', old.\"y_coordinate_field\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_occurrence_imports_into_oplog\n  AFTER UPDATE ON \"public\".\"occurrence_imports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_occurrence_imports_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_occurrence_imports_into_oplog ON \"public\".\"occurrence_imports\";",
      "    CREATE OR REPLACE FUNCTION delete_public_occurrence_imports_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'occurrence_imports';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'occurrence_imports',\n            'DELETE',\n            json_strip_nulls(json_build_object('occurrence_import_id', old.\"occurrence_import_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'attribution', old.\"attribution\", 'created_time', old.\"created_time\", 'crs', old.\"crs\", 'download_from_gbif', old.\"download_from_gbif\", 'gbif_download_key', old.\"gbif_download_key\", 'gbif_error', old.\"gbif_error\", 'gbif_filters', old.\"gbif_filters\", 'geojson_geometry_field', old.\"geojson_geometry_field\", 'geometry_method', old.\"geometry_method\", 'id_field', old.\"id_field\", 'inserted_count', old.\"inserted_count\", 'label_creation', old.\"label_creation\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'name', old.\"name\", 'occurrence_import_id', old.\"occurrence_import_id\", 'previous_import', old.\"previous_import\", 'previous_import_operation', old.\"previous_import_operation\", 'subproject_id', old.\"subproject_id\", 'x_coordinate_field', old.\"x_coordinate_field\", 'y_coordinate_field', old.\"y_coordinate_field\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_occurrence_imports_into_oplog\n  AFTER DELETE ON \"public\".\"occurrence_imports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_occurrence_imports_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_occurrence_imports_account_id_into_oplog ON \"public\".\"occurrence_imports\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_occurrence_imports_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'occurrence_imports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_occurrence_imports_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"occurrence_imports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_occurrence_imports_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_occurrence_imports_account_id_into_oplog ON \"public\".\"occurrence_imports\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_occurrence_imports_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'occurrence_imports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_occurrence_imports_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"occurrence_imports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_occurrence_imports_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_occurrence_imports_previous_import_into_oplog ON \"public\".\"occurrence_imports\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_occurrence_imports_previous_import_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'occurrence_imports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'occurrence_imports',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('occurrence_import_id', \"occurrence_import_id\"))),\n            jsonb_build_object('occurrence_import_id', \"occurrence_import_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"occurrence_imports\"\n          WHERE \"occurrence_import_id\" = NEW.\"previous_import\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_occurrence_imports_previous_import_into_oplog\n  AFTER INSERT ON \"public\".\"occurrence_imports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_occurrence_imports_previous_import_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_occurrence_imports_previous_import_into_oplog ON \"public\".\"occurrence_imports\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_occurrence_imports_previous_import_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'occurrence_imports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'occurrence_imports',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('occurrence_import_id', \"occurrence_import_id\"))),\n            jsonb_build_object('occurrence_import_id', \"occurrence_import_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"occurrence_imports\"\n          WHERE \"occurrence_import_id\" = NEW.\"previous_import\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_occurrence_imports_previous_import_into_oplog\n  AFTER UPDATE ON \"public\".\"occurrence_imports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_occurrence_imports_previous_import_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_occurrence_imports_subproject_id_into_oplog ON \"public\".\"occurrence_imports\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_occurrence_imports_subproject_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'occurrence_imports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'subprojects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('subproject_id', \"subproject_id\"))),\n            jsonb_build_object('subproject_id', \"subproject_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"subprojects\"\n          WHERE \"subproject_id\" = NEW.\"subproject_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_occurrence_imports_subproject_id_into_oplog\n  AFTER INSERT ON \"public\".\"occurrence_imports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_occurrence_imports_subproject_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_occurrence_imports_subproject_id_into_oplog ON \"public\".\"occurrence_imports\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_occurrence_imports_subproject_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'occurrence_imports';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'subprojects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('subproject_id', \"subproject_id\"))),\n            jsonb_build_object('subproject_id', \"subproject_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"subprojects\"\n          WHERE \"subproject_id\" = NEW.\"subproject_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_occurrence_imports_subproject_id_into_oplog\n  AFTER UPDATE ON \"public\".\"occurrence_imports\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_occurrence_imports_subproject_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'occurrences', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_occurrences_primarykey ON \"public\".\"occurrences\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_occurrences_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"occurrence_id\" IS DISTINCT FROM NEW.\"occurrence_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column occurrence_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_occurrences_primarykey\n  BEFORE UPDATE ON \"public\".\"occurrences\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_occurrences_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_occurrences_into_oplog ON \"public\".\"occurrences\";",
      "    CREATE OR REPLACE FUNCTION insert_public_occurrences_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'occurrences';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'occurrences',\n            'INSERT',\n            json_strip_nulls(json_build_object('occurrence_id', new.\"occurrence_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'comment', new.\"comment\", 'data', new.\"data\", 'geometry', new.\"geometry\", 'id_in_source', new.\"id_in_source\", 'label', new.\"label\", 'not_to_assign', new.\"not_to_assign\", 'occurrence_id', new.\"occurrence_id\", 'occurrence_import_id', new.\"occurrence_import_id\", 'place_id', new.\"place_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_occurrences_into_oplog\n  AFTER INSERT ON \"public\".\"occurrences\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_occurrences_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_occurrences_into_oplog ON \"public\".\"occurrences\";",
      "    CREATE OR REPLACE FUNCTION update_public_occurrences_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'occurrences';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'occurrences',\n            'UPDATE',\n            json_strip_nulls(json_build_object('occurrence_id', new.\"occurrence_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'comment', new.\"comment\", 'data', new.\"data\", 'geometry', new.\"geometry\", 'id_in_source', new.\"id_in_source\", 'label', new.\"label\", 'not_to_assign', new.\"not_to_assign\", 'occurrence_id', new.\"occurrence_id\", 'occurrence_import_id', new.\"occurrence_import_id\", 'place_id', new.\"place_id\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'comment', old.\"comment\", 'data', old.\"data\", 'geometry', old.\"geometry\", 'id_in_source', old.\"id_in_source\", 'label', old.\"label\", 'not_to_assign', old.\"not_to_assign\", 'occurrence_id', old.\"occurrence_id\", 'occurrence_import_id', old.\"occurrence_import_id\", 'place_id', old.\"place_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_occurrences_into_oplog\n  AFTER UPDATE ON \"public\".\"occurrences\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_occurrences_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_occurrences_into_oplog ON \"public\".\"occurrences\";",
      "    CREATE OR REPLACE FUNCTION delete_public_occurrences_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'occurrences';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'occurrences',\n            'DELETE',\n            json_strip_nulls(json_build_object('occurrence_id', old.\"occurrence_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'comment', old.\"comment\", 'data', old.\"data\", 'geometry', old.\"geometry\", 'id_in_source', old.\"id_in_source\", 'label', old.\"label\", 'not_to_assign', old.\"not_to_assign\", 'occurrence_id', old.\"occurrence_id\", 'occurrence_import_id', old.\"occurrence_import_id\", 'place_id', old.\"place_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_occurrences_into_oplog\n  AFTER DELETE ON \"public\".\"occurrences\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_occurrences_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_occurrences_account_id_into_oplog ON \"public\".\"occurrences\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_occurrences_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'occurrences';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_occurrences_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"occurrences\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_occurrences_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_occurrences_account_id_into_oplog ON \"public\".\"occurrences\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_occurrences_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'occurrences';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_occurrences_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"occurrences\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_occurrences_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_occurrences_occurrence_import_id_into_oplog ON \"public\".\"occurrences\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_occurrences_occurrence_import_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'occurrences';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'occurrence_imports',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('occurrence_import_id', \"occurrence_import_id\"))),\n            jsonb_build_object('occurrence_import_id', \"occurrence_import_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"occurrence_imports\"\n          WHERE \"occurrence_import_id\" = NEW.\"occurrence_import_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_occurrences_occurrence_import_id_into_oplog\n  AFTER INSERT ON \"public\".\"occurrences\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_occurrences_occurrence_import_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_occurrences_occurrence_import_id_into_oplog ON \"public\".\"occurrences\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_occurrences_occurrence_import_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'occurrences';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'occurrence_imports',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('occurrence_import_id', \"occurrence_import_id\"))),\n            jsonb_build_object('occurrence_import_id', \"occurrence_import_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"occurrence_imports\"\n          WHERE \"occurrence_import_id\" = NEW.\"occurrence_import_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_occurrences_occurrence_import_id_into_oplog\n  AFTER UPDATE ON \"public\".\"occurrences\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_occurrences_occurrence_import_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_occurrences_place_id_into_oplog ON \"public\".\"occurrences\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_occurrences_place_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'occurrences';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'places',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('place_id', \"place_id\"))),\n            jsonb_build_object('place_id', \"place_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"places\"\n          WHERE \"place_id\" = NEW.\"place_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_occurrences_place_id_into_oplog\n  AFTER INSERT ON \"public\".\"occurrences\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_occurrences_place_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_occurrences_place_id_into_oplog ON \"public\".\"occurrences\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_occurrences_place_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'occurrences';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'places',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('place_id', \"place_id\"))),\n            jsonb_build_object('place_id', \"place_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"places\"\n          WHERE \"place_id\" = NEW.\"place_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_occurrences_place_id_into_oplog\n  AFTER UPDATE ON \"public\".\"occurrences\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_occurrences_place_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'wms_layers', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_wms_layers_primarykey ON \"public\".\"wms_layers\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_wms_layers_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"wms_layer_id\" IS DISTINCT FROM NEW.\"wms_layer_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column wms_layer_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_wms_layers_primarykey\n  BEFORE UPDATE ON \"public\".\"wms_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_wms_layers_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_wms_layers_into_oplog ON \"public\".\"wms_layers\";",
      "    CREATE OR REPLACE FUNCTION insert_public_wms_layers_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_layers';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'wms_layers',\n            'INSERT',\n            json_strip_nulls(json_build_object('wms_layer_id', new.\"wms_layer_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label', new.\"label\", 'local_data_bounds', new.\"local_data_bounds\", 'local_data_size', new.\"local_data_size\", 'project_id', new.\"project_id\", 'wms_layer_id', new.\"wms_layer_id\", 'wms_service_id', new.\"wms_service_id\", 'wms_service_layer_name', new.\"wms_service_layer_name\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_wms_layers_into_oplog\n  AFTER INSERT ON \"public\".\"wms_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_wms_layers_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_wms_layers_into_oplog ON \"public\".\"wms_layers\";",
      "    CREATE OR REPLACE FUNCTION update_public_wms_layers_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_layers';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'wms_layers',\n            'UPDATE',\n            json_strip_nulls(json_build_object('wms_layer_id', new.\"wms_layer_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label', new.\"label\", 'local_data_bounds', new.\"local_data_bounds\", 'local_data_size', new.\"local_data_size\", 'project_id', new.\"project_id\", 'wms_layer_id', new.\"wms_layer_id\", 'wms_service_id', new.\"wms_service_id\", 'wms_service_layer_name', new.\"wms_service_layer_name\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'label', old.\"label\", 'local_data_bounds', old.\"local_data_bounds\", 'local_data_size', old.\"local_data_size\", 'project_id', old.\"project_id\", 'wms_layer_id', old.\"wms_layer_id\", 'wms_service_id', old.\"wms_service_id\", 'wms_service_layer_name', old.\"wms_service_layer_name\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_wms_layers_into_oplog\n  AFTER UPDATE ON \"public\".\"wms_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_wms_layers_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_wms_layers_into_oplog ON \"public\".\"wms_layers\";",
      "    CREATE OR REPLACE FUNCTION delete_public_wms_layers_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_layers';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'wms_layers',\n            'DELETE',\n            json_strip_nulls(json_build_object('wms_layer_id', old.\"wms_layer_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'label', old.\"label\", 'local_data_bounds', old.\"local_data_bounds\", 'local_data_size', old.\"local_data_size\", 'project_id', old.\"project_id\", 'wms_layer_id', old.\"wms_layer_id\", 'wms_service_id', old.\"wms_service_id\", 'wms_service_layer_name', old.\"wms_service_layer_name\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_wms_layers_into_oplog\n  AFTER DELETE ON \"public\".\"wms_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_wms_layers_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_wms_layers_account_id_into_oplog ON \"public\".\"wms_layers\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_wms_layers_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_layers';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_wms_layers_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"wms_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_wms_layers_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_wms_layers_account_id_into_oplog ON \"public\".\"wms_layers\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_wms_layers_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_layers';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_wms_layers_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"wms_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_wms_layers_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_wms_layers_project_id_into_oplog ON \"public\".\"wms_layers\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_wms_layers_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_layers';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_wms_layers_project_id_into_oplog\n  AFTER INSERT ON \"public\".\"wms_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_wms_layers_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_wms_layers_project_id_into_oplog ON \"public\".\"wms_layers\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_wms_layers_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_layers';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_wms_layers_project_id_into_oplog\n  AFTER UPDATE ON \"public\".\"wms_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_wms_layers_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_wms_layers_wms_service_id_into_oplog ON \"public\".\"wms_layers\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_wms_layers_wms_service_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_layers';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'wms_services',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('wms_service_id', \"wms_service_id\"))),\n            jsonb_build_object('wms_service_id', \"wms_service_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"wms_services\"\n          WHERE \"wms_service_id\" = NEW.\"wms_service_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_wms_layers_wms_service_id_into_oplog\n  AFTER INSERT ON \"public\".\"wms_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_wms_layers_wms_service_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_wms_layers_wms_service_id_into_oplog ON \"public\".\"wms_layers\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_wms_layers_wms_service_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_layers';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'wms_services',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('wms_service_id', \"wms_service_id\"))),\n            jsonb_build_object('wms_service_id', \"wms_service_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"wms_services\"\n          WHERE \"wms_service_id\" = NEW.\"wms_service_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_wms_layers_wms_service_id_into_oplog\n  AFTER UPDATE ON \"public\".\"wms_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_wms_layers_wms_service_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'vector_layers', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_vector_layers_primarykey ON \"public\".\"vector_layers\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_vector_layers_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"vector_layer_id\" IS DISTINCT FROM NEW.\"vector_layer_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column vector_layer_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_vector_layers_primarykey\n  BEFORE UPDATE ON \"public\".\"vector_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_vector_layers_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_vector_layers_into_oplog ON \"public\".\"vector_layers\";",
      "    CREATE OR REPLACE FUNCTION insert_public_vector_layers_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layers';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'vector_layers',\n            'INSERT',\n            json_strip_nulls(json_build_object('vector_layer_id', new.\"vector_layer_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'display_by_property', new.\"display_by_property\", 'feature_count', new.\"feature_count\", 'label', new.\"label\", 'line_count', new.\"line_count\", 'max_features', new.\"max_features\", 'own_table', new.\"own_table\", 'own_table_level', new.\"own_table_level\", 'point_count', new.\"point_count\", 'polygon_count', new.\"polygon_count\", 'project_id', new.\"project_id\", 'properties', new.\"properties\", 'type', new.\"type\", 'vector_layer_id', new.\"vector_layer_id\", 'wfs_service_id', new.\"wfs_service_id\", 'wfs_service_layer_name', new.\"wfs_service_layer_name\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_vector_layers_into_oplog\n  AFTER INSERT ON \"public\".\"vector_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_vector_layers_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_vector_layers_into_oplog ON \"public\".\"vector_layers\";",
      "    CREATE OR REPLACE FUNCTION update_public_vector_layers_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layers';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'vector_layers',\n            'UPDATE',\n            json_strip_nulls(json_build_object('vector_layer_id', new.\"vector_layer_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'display_by_property', new.\"display_by_property\", 'feature_count', new.\"feature_count\", 'label', new.\"label\", 'line_count', new.\"line_count\", 'max_features', new.\"max_features\", 'own_table', new.\"own_table\", 'own_table_level', new.\"own_table_level\", 'point_count', new.\"point_count\", 'polygon_count', new.\"polygon_count\", 'project_id', new.\"project_id\", 'properties', new.\"properties\", 'type', new.\"type\", 'vector_layer_id', new.\"vector_layer_id\", 'wfs_service_id', new.\"wfs_service_id\", 'wfs_service_layer_name', new.\"wfs_service_layer_name\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'display_by_property', old.\"display_by_property\", 'feature_count', old.\"feature_count\", 'label', old.\"label\", 'line_count', old.\"line_count\", 'max_features', old.\"max_features\", 'own_table', old.\"own_table\", 'own_table_level', old.\"own_table_level\", 'point_count', old.\"point_count\", 'polygon_count', old.\"polygon_count\", 'project_id', old.\"project_id\", 'properties', old.\"properties\", 'type', old.\"type\", 'vector_layer_id', old.\"vector_layer_id\", 'wfs_service_id', old.\"wfs_service_id\", 'wfs_service_layer_name', old.\"wfs_service_layer_name\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_vector_layers_into_oplog\n  AFTER UPDATE ON \"public\".\"vector_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_vector_layers_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_vector_layers_into_oplog ON \"public\".\"vector_layers\";",
      "    CREATE OR REPLACE FUNCTION delete_public_vector_layers_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layers';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'vector_layers',\n            'DELETE',\n            json_strip_nulls(json_build_object('vector_layer_id', old.\"vector_layer_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'display_by_property', old.\"display_by_property\", 'feature_count', old.\"feature_count\", 'label', old.\"label\", 'line_count', old.\"line_count\", 'max_features', old.\"max_features\", 'own_table', old.\"own_table\", 'own_table_level', old.\"own_table_level\", 'point_count', old.\"point_count\", 'polygon_count', old.\"polygon_count\", 'project_id', old.\"project_id\", 'properties', old.\"properties\", 'type', old.\"type\", 'vector_layer_id', old.\"vector_layer_id\", 'wfs_service_id', old.\"wfs_service_id\", 'wfs_service_layer_name', old.\"wfs_service_layer_name\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_vector_layers_into_oplog\n  AFTER DELETE ON \"public\".\"vector_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_vector_layers_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_vector_layers_account_id_into_oplog ON \"public\".\"vector_layers\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_vector_layers_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layers';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_vector_layers_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"vector_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_vector_layers_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_vector_layers_account_id_into_oplog ON \"public\".\"vector_layers\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_vector_layers_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layers';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_vector_layers_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"vector_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_vector_layers_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_vector_layers_project_id_into_oplog ON \"public\".\"vector_layers\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_vector_layers_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layers';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_vector_layers_project_id_into_oplog\n  AFTER INSERT ON \"public\".\"vector_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_vector_layers_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_vector_layers_project_id_into_oplog ON \"public\".\"vector_layers\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_vector_layers_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layers';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_vector_layers_project_id_into_oplog\n  AFTER UPDATE ON \"public\".\"vector_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_vector_layers_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_vector_layers_wfs_service_id_into_oplog ON \"public\".\"vector_layers\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_vector_layers_wfs_service_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layers';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'wfs_services',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('wfs_service_id', \"wfs_service_id\"))),\n            jsonb_build_object('wfs_service_id', \"wfs_service_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"wfs_services\"\n          WHERE \"wfs_service_id\" = NEW.\"wfs_service_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_vector_layers_wfs_service_id_into_oplog\n  AFTER INSERT ON \"public\".\"vector_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_vector_layers_wfs_service_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_vector_layers_wfs_service_id_into_oplog ON \"public\".\"vector_layers\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_vector_layers_wfs_service_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layers';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'wfs_services',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('wfs_service_id', \"wfs_service_id\"))),\n            jsonb_build_object('wfs_service_id', \"wfs_service_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"wfs_services\"\n          WHERE \"wfs_service_id\" = NEW.\"wfs_service_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_vector_layers_wfs_service_id_into_oplog\n  AFTER UPDATE ON \"public\".\"vector_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_vector_layers_wfs_service_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'vector_layer_geoms', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_vector_layer_geoms_primarykey ON \"public\".\"vector_layer_geoms\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_vector_layer_geoms_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"vector_layer_geom_id\" IS DISTINCT FROM NEW.\"vector_layer_geom_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column vector_layer_geom_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_vector_layer_geoms_primarykey\n  BEFORE UPDATE ON \"public\".\"vector_layer_geoms\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_vector_layer_geoms_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_vector_layer_geoms_into_oplog ON \"public\".\"vector_layer_geoms\";",
      "    CREATE OR REPLACE FUNCTION insert_public_vector_layer_geoms_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layer_geoms';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'vector_layer_geoms',\n            'INSERT',\n            json_strip_nulls(json_build_object('vector_layer_geom_id', new.\"vector_layer_geom_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'bbox_ne_lat', cast(new.\"bbox_ne_lat\" as TEXT), 'bbox_ne_lng', cast(new.\"bbox_ne_lng\" as TEXT), 'bbox_sw_lat', cast(new.\"bbox_sw_lat\" as TEXT), 'bbox_sw_lng', cast(new.\"bbox_sw_lng\" as TEXT), 'geometry', new.\"geometry\", 'properties', new.\"properties\", 'vector_layer_geom_id', new.\"vector_layer_geom_id\", 'vector_layer_id', new.\"vector_layer_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_vector_layer_geoms_into_oplog\n  AFTER INSERT ON \"public\".\"vector_layer_geoms\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_vector_layer_geoms_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_vector_layer_geoms_into_oplog ON \"public\".\"vector_layer_geoms\";",
      "    CREATE OR REPLACE FUNCTION update_public_vector_layer_geoms_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layer_geoms';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'vector_layer_geoms',\n            'UPDATE',\n            json_strip_nulls(json_build_object('vector_layer_geom_id', new.\"vector_layer_geom_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'bbox_ne_lat', cast(new.\"bbox_ne_lat\" as TEXT), 'bbox_ne_lng', cast(new.\"bbox_ne_lng\" as TEXT), 'bbox_sw_lat', cast(new.\"bbox_sw_lat\" as TEXT), 'bbox_sw_lng', cast(new.\"bbox_sw_lng\" as TEXT), 'geometry', new.\"geometry\", 'properties', new.\"properties\", 'vector_layer_geom_id', new.\"vector_layer_geom_id\", 'vector_layer_id', new.\"vector_layer_id\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'bbox_ne_lat', cast(old.\"bbox_ne_lat\" as TEXT), 'bbox_ne_lng', cast(old.\"bbox_ne_lng\" as TEXT), 'bbox_sw_lat', cast(old.\"bbox_sw_lat\" as TEXT), 'bbox_sw_lng', cast(old.\"bbox_sw_lng\" as TEXT), 'geometry', old.\"geometry\", 'properties', old.\"properties\", 'vector_layer_geom_id', old.\"vector_layer_geom_id\", 'vector_layer_id', old.\"vector_layer_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_vector_layer_geoms_into_oplog\n  AFTER UPDATE ON \"public\".\"vector_layer_geoms\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_vector_layer_geoms_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_vector_layer_geoms_into_oplog ON \"public\".\"vector_layer_geoms\";",
      "    CREATE OR REPLACE FUNCTION delete_public_vector_layer_geoms_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layer_geoms';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'vector_layer_geoms',\n            'DELETE',\n            json_strip_nulls(json_build_object('vector_layer_geom_id', old.\"vector_layer_geom_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'bbox_ne_lat', cast(old.\"bbox_ne_lat\" as TEXT), 'bbox_ne_lng', cast(old.\"bbox_ne_lng\" as TEXT), 'bbox_sw_lat', cast(old.\"bbox_sw_lat\" as TEXT), 'bbox_sw_lng', cast(old.\"bbox_sw_lng\" as TEXT), 'geometry', old.\"geometry\", 'properties', old.\"properties\", 'vector_layer_geom_id', old.\"vector_layer_geom_id\", 'vector_layer_id', old.\"vector_layer_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_vector_layer_geoms_into_oplog\n  AFTER DELETE ON \"public\".\"vector_layer_geoms\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_vector_layer_geoms_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_vector_layer_geoms_account_id_into_oplog ON \"public\".\"vector_layer_geoms\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_vector_layer_geoms_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layer_geoms';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_vector_layer_geoms_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"vector_layer_geoms\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_vector_layer_geoms_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_vector_layer_geoms_account_id_into_oplog ON \"public\".\"vector_layer_geoms\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_vector_layer_geoms_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layer_geoms';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_vector_layer_geoms_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"vector_layer_geoms\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_vector_layer_geoms_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_vector_layer_geoms_vector_layer_id_into_oplog ON \"public\".\"vector_layer_geoms\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_vector_layer_geoms_vector_layer_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layer_geoms';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'vector_layers',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('vector_layer_id', \"vector_layer_id\"))),\n            jsonb_build_object('vector_layer_id', \"vector_layer_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"vector_layers\"\n          WHERE \"vector_layer_id\" = NEW.\"vector_layer_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_vector_layer_geoms_vector_layer_id_into_oplog\n  AFTER INSERT ON \"public\".\"vector_layer_geoms\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_vector_layer_geoms_vector_layer_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_vector_layer_geoms_vector_layer_id_into_oplog ON \"public\".\"vector_layer_geoms\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_vector_layer_geoms_vector_layer_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layer_geoms';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'vector_layers',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('vector_layer_id', \"vector_layer_id\"))),\n            jsonb_build_object('vector_layer_id', \"vector_layer_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"vector_layers\"\n          WHERE \"vector_layer_id\" = NEW.\"vector_layer_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_vector_layer_geoms_vector_layer_id_into_oplog\n  AFTER UPDATE ON \"public\".\"vector_layer_geoms\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_vector_layer_geoms_vector_layer_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'vector_layer_displays', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_vector_layer_displays_primarykey ON \"public\".\"vector_layer_displays\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_vector_layer_displays_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"vector_layer_display_id\" IS DISTINCT FROM NEW.\"vector_layer_display_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column vector_layer_display_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_vector_layer_displays_primarykey\n  BEFORE UPDATE ON \"public\".\"vector_layer_displays\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_vector_layer_displays_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_vector_layer_displays_into_oplog ON \"public\".\"vector_layer_displays\";",
      "    CREATE OR REPLACE FUNCTION insert_public_vector_layer_displays_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layer_displays';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'vector_layer_displays',\n            'INSERT',\n            json_strip_nulls(json_build_object('vector_layer_display_id', new.\"vector_layer_display_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'circle_marker_radius', new.\"circle_marker_radius\", 'color', new.\"color\", 'dash_array', new.\"dash_array\", 'dash_offset', new.\"dash_offset\", 'display_property_value', new.\"display_property_value\", 'fill', new.\"fill\", 'fill_color', new.\"fill_color\", 'fill_opacity_percent', new.\"fill_opacity_percent\", 'fill_rule', new.\"fill_rule\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'line_cap', new.\"line_cap\", 'line_join', new.\"line_join\", 'marker_size', new.\"marker_size\", 'marker_symbol', new.\"marker_symbol\", 'marker_type', new.\"marker_type\", 'stroke', new.\"stroke\", 'vector_layer_display_id', new.\"vector_layer_display_id\", 'vector_layer_id', new.\"vector_layer_id\", 'weight', new.\"weight\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_vector_layer_displays_into_oplog\n  AFTER INSERT ON \"public\".\"vector_layer_displays\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_vector_layer_displays_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_vector_layer_displays_into_oplog ON \"public\".\"vector_layer_displays\";",
      "    CREATE OR REPLACE FUNCTION update_public_vector_layer_displays_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layer_displays';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'vector_layer_displays',\n            'UPDATE',\n            json_strip_nulls(json_build_object('vector_layer_display_id', new.\"vector_layer_display_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'circle_marker_radius', new.\"circle_marker_radius\", 'color', new.\"color\", 'dash_array', new.\"dash_array\", 'dash_offset', new.\"dash_offset\", 'display_property_value', new.\"display_property_value\", 'fill', new.\"fill\", 'fill_color', new.\"fill_color\", 'fill_opacity_percent', new.\"fill_opacity_percent\", 'fill_rule', new.\"fill_rule\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'line_cap', new.\"line_cap\", 'line_join', new.\"line_join\", 'marker_size', new.\"marker_size\", 'marker_symbol', new.\"marker_symbol\", 'marker_type', new.\"marker_type\", 'stroke', new.\"stroke\", 'vector_layer_display_id', new.\"vector_layer_display_id\", 'vector_layer_id', new.\"vector_layer_id\", 'weight', new.\"weight\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'circle_marker_radius', old.\"circle_marker_radius\", 'color', old.\"color\", 'dash_array', old.\"dash_array\", 'dash_offset', old.\"dash_offset\", 'display_property_value', old.\"display_property_value\", 'fill', old.\"fill\", 'fill_color', old.\"fill_color\", 'fill_opacity_percent', old.\"fill_opacity_percent\", 'fill_rule', old.\"fill_rule\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'line_cap', old.\"line_cap\", 'line_join', old.\"line_join\", 'marker_size', old.\"marker_size\", 'marker_symbol', old.\"marker_symbol\", 'marker_type', old.\"marker_type\", 'stroke', old.\"stroke\", 'vector_layer_display_id', old.\"vector_layer_display_id\", 'vector_layer_id', old.\"vector_layer_id\", 'weight', old.\"weight\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_vector_layer_displays_into_oplog\n  AFTER UPDATE ON \"public\".\"vector_layer_displays\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_vector_layer_displays_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_vector_layer_displays_into_oplog ON \"public\".\"vector_layer_displays\";",
      "    CREATE OR REPLACE FUNCTION delete_public_vector_layer_displays_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layer_displays';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'vector_layer_displays',\n            'DELETE',\n            json_strip_nulls(json_build_object('vector_layer_display_id', old.\"vector_layer_display_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'circle_marker_radius', old.\"circle_marker_radius\", 'color', old.\"color\", 'dash_array', old.\"dash_array\", 'dash_offset', old.\"dash_offset\", 'display_property_value', old.\"display_property_value\", 'fill', old.\"fill\", 'fill_color', old.\"fill_color\", 'fill_opacity_percent', old.\"fill_opacity_percent\", 'fill_rule', old.\"fill_rule\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'line_cap', old.\"line_cap\", 'line_join', old.\"line_join\", 'marker_size', old.\"marker_size\", 'marker_symbol', old.\"marker_symbol\", 'marker_type', old.\"marker_type\", 'stroke', old.\"stroke\", 'vector_layer_display_id', old.\"vector_layer_display_id\", 'vector_layer_id', old.\"vector_layer_id\", 'weight', old.\"weight\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_vector_layer_displays_into_oplog\n  AFTER DELETE ON \"public\".\"vector_layer_displays\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_vector_layer_displays_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_vector_layer_displays_account_id_into_oplog ON \"public\".\"vector_layer_displays\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_vector_layer_displays_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layer_displays';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_vector_layer_displays_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"vector_layer_displays\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_vector_layer_displays_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_vector_layer_displays_account_id_into_oplog ON \"public\".\"vector_layer_displays\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_vector_layer_displays_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layer_displays';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_vector_layer_displays_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"vector_layer_displays\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_vector_layer_displays_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_vector_layer_displays_vector_layer_id_into_oplog ON \"public\".\"vector_layer_displays\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_vector_layer_displays_vector_layer_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layer_displays';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'vector_layers',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('vector_layer_id', \"vector_layer_id\"))),\n            jsonb_build_object('vector_layer_id', \"vector_layer_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"vector_layers\"\n          WHERE \"vector_layer_id\" = NEW.\"vector_layer_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_vector_layer_displays_vector_layer_id_into_oplog\n  AFTER INSERT ON \"public\".\"vector_layer_displays\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_vector_layer_displays_vector_layer_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_vector_layer_displays_vector_layer_id_into_oplog ON \"public\".\"vector_layer_displays\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_vector_layer_displays_vector_layer_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'vector_layer_displays';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'vector_layers',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('vector_layer_id', \"vector_layer_id\"))),\n            jsonb_build_object('vector_layer_id', \"vector_layer_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"vector_layers\"\n          WHERE \"vector_layer_id\" = NEW.\"vector_layer_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_vector_layer_displays_vector_layer_id_into_oplog\n  AFTER UPDATE ON \"public\".\"vector_layer_displays\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_vector_layer_displays_vector_layer_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'notifications', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_notifications_primarykey ON \"public\".\"notifications\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_notifications_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"notification_id\" IS DISTINCT FROM NEW.\"notification_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column notification_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_notifications_primarykey\n  BEFORE UPDATE ON \"public\".\"notifications\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_notifications_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_notifications_into_oplog ON \"public\".\"notifications\";",
      "    CREATE OR REPLACE FUNCTION insert_public_notifications_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'notifications';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'notifications',\n            'INSERT',\n            json_strip_nulls(json_build_object('notification_id', new.\"notification_id\")),\n            jsonb_build_object('body', new.\"body\", 'intent', new.\"intent\", 'notification_id', new.\"notification_id\", 'paused', new.\"paused\", 'progress_percent', new.\"progress_percent\", 'timeout', new.\"timeout\", 'title', new.\"title\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_notifications_into_oplog\n  AFTER INSERT ON \"public\".\"notifications\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_notifications_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_notifications_into_oplog ON \"public\".\"notifications\";",
      "    CREATE OR REPLACE FUNCTION update_public_notifications_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'notifications';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'notifications',\n            'UPDATE',\n            json_strip_nulls(json_build_object('notification_id', new.\"notification_id\")),\n            jsonb_build_object('body', new.\"body\", 'intent', new.\"intent\", 'notification_id', new.\"notification_id\", 'paused', new.\"paused\", 'progress_percent', new.\"progress_percent\", 'timeout', new.\"timeout\", 'title', new.\"title\"),\n            jsonb_build_object('body', old.\"body\", 'intent', old.\"intent\", 'notification_id', old.\"notification_id\", 'paused', old.\"paused\", 'progress_percent', old.\"progress_percent\", 'timeout', old.\"timeout\", 'title', old.\"title\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_notifications_into_oplog\n  AFTER UPDATE ON \"public\".\"notifications\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_notifications_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_notifications_into_oplog ON \"public\".\"notifications\";",
      "    CREATE OR REPLACE FUNCTION delete_public_notifications_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'notifications';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'notifications',\n            'DELETE',\n            json_strip_nulls(json_build_object('notification_id', old.\"notification_id\")),\n            NULL,\n            jsonb_build_object('body', old.\"body\", 'intent', old.\"intent\", 'notification_id', old.\"notification_id\", 'paused', old.\"paused\", 'progress_percent', old.\"progress_percent\", 'timeout', old.\"timeout\", 'title', old.\"title\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_notifications_into_oplog\n  AFTER DELETE ON \"public\".\"notifications\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_notifications_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'charts', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_charts_primarykey ON \"public\".\"charts\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_charts_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"chart_id\" IS DISTINCT FROM NEW.\"chart_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column chart_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_charts_primarykey\n  BEFORE UPDATE ON \"public\".\"charts\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_charts_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_charts_into_oplog ON \"public\".\"charts\";",
      "    CREATE OR REPLACE FUNCTION insert_public_charts_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'charts';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'charts',\n            'INSERT',\n            json_strip_nulls(json_build_object('chart_id', new.\"chart_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'chart_id', new.\"chart_id\", 'chart_type', new.\"chart_type\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'percent', new.\"percent\", 'place_id', new.\"place_id\", 'project_id', new.\"project_id\", 'subjects_single', new.\"subjects_single\", 'subjects_stacked', new.\"subjects_stacked\", 'subproject_id', new.\"subproject_id\", 'title', new.\"title\", 'years_current', new.\"years_current\", 'years_last_x', new.\"years_last_x\", 'years_previous', new.\"years_previous\", 'years_since', new.\"years_since\", 'years_specific', new.\"years_specific\", 'years_until', new.\"years_until\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_charts_into_oplog\n  AFTER INSERT ON \"public\".\"charts\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_charts_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_charts_into_oplog ON \"public\".\"charts\";",
      "    CREATE OR REPLACE FUNCTION update_public_charts_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'charts';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'charts',\n            'UPDATE',\n            json_strip_nulls(json_build_object('chart_id', new.\"chart_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'chart_id', new.\"chart_id\", 'chart_type', new.\"chart_type\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'percent', new.\"percent\", 'place_id', new.\"place_id\", 'project_id', new.\"project_id\", 'subjects_single', new.\"subjects_single\", 'subjects_stacked', new.\"subjects_stacked\", 'subproject_id', new.\"subproject_id\", 'title', new.\"title\", 'years_current', new.\"years_current\", 'years_last_x', new.\"years_last_x\", 'years_previous', new.\"years_previous\", 'years_since', new.\"years_since\", 'years_specific', new.\"years_specific\", 'years_until', new.\"years_until\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'chart_id', old.\"chart_id\", 'chart_type', old.\"chart_type\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'percent', old.\"percent\", 'place_id', old.\"place_id\", 'project_id', old.\"project_id\", 'subjects_single', old.\"subjects_single\", 'subjects_stacked', old.\"subjects_stacked\", 'subproject_id', old.\"subproject_id\", 'title', old.\"title\", 'years_current', old.\"years_current\", 'years_last_x', old.\"years_last_x\", 'years_previous', old.\"years_previous\", 'years_since', old.\"years_since\", 'years_specific', old.\"years_specific\", 'years_until', old.\"years_until\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_charts_into_oplog\n  AFTER UPDATE ON \"public\".\"charts\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_charts_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_charts_into_oplog ON \"public\".\"charts\";",
      "    CREATE OR REPLACE FUNCTION delete_public_charts_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'charts';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'charts',\n            'DELETE',\n            json_strip_nulls(json_build_object('chart_id', old.\"chart_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'chart_id', old.\"chart_id\", 'chart_type', old.\"chart_type\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'percent', old.\"percent\", 'place_id', old.\"place_id\", 'project_id', old.\"project_id\", 'subjects_single', old.\"subjects_single\", 'subjects_stacked', old.\"subjects_stacked\", 'subproject_id', old.\"subproject_id\", 'title', old.\"title\", 'years_current', old.\"years_current\", 'years_last_x', old.\"years_last_x\", 'years_previous', old.\"years_previous\", 'years_since', old.\"years_since\", 'years_specific', old.\"years_specific\", 'years_until', old.\"years_until\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_charts_into_oplog\n  AFTER DELETE ON \"public\".\"charts\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_charts_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_charts_account_id_into_oplog ON \"public\".\"charts\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_charts_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'charts';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_charts_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"charts\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_charts_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_charts_account_id_into_oplog ON \"public\".\"charts\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_charts_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'charts';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_charts_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"charts\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_charts_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_charts_place_id_into_oplog ON \"public\".\"charts\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_charts_place_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'charts';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'places',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('place_id', \"place_id\"))),\n            jsonb_build_object('place_id', \"place_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"places\"\n          WHERE \"place_id\" = NEW.\"place_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_charts_place_id_into_oplog\n  AFTER INSERT ON \"public\".\"charts\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_charts_place_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_charts_place_id_into_oplog ON \"public\".\"charts\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_charts_place_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'charts';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'places',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('place_id', \"place_id\"))),\n            jsonb_build_object('place_id', \"place_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"places\"\n          WHERE \"place_id\" = NEW.\"place_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_charts_place_id_into_oplog\n  AFTER UPDATE ON \"public\".\"charts\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_charts_place_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_charts_project_id_into_oplog ON \"public\".\"charts\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_charts_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'charts';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_charts_project_id_into_oplog\n  AFTER INSERT ON \"public\".\"charts\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_charts_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_charts_project_id_into_oplog ON \"public\".\"charts\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_charts_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'charts';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_charts_project_id_into_oplog\n  AFTER UPDATE ON \"public\".\"charts\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_charts_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_charts_subproject_id_into_oplog ON \"public\".\"charts\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_charts_subproject_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'charts';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'subprojects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('subproject_id', \"subproject_id\"))),\n            jsonb_build_object('subproject_id', \"subproject_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"subprojects\"\n          WHERE \"subproject_id\" = NEW.\"subproject_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_charts_subproject_id_into_oplog\n  AFTER INSERT ON \"public\".\"charts\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_charts_subproject_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_charts_subproject_id_into_oplog ON \"public\".\"charts\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_charts_subproject_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'charts';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'subprojects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('subproject_id', \"subproject_id\"))),\n            jsonb_build_object('subproject_id', \"subproject_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"subprojects\"\n          WHERE \"subproject_id\" = NEW.\"subproject_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_charts_subproject_id_into_oplog\n  AFTER UPDATE ON \"public\".\"charts\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_charts_subproject_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'chart_subjects', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_chart_subjects_primarykey ON \"public\".\"chart_subjects\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_chart_subjects_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"chart_subject_id\" IS DISTINCT FROM NEW.\"chart_subject_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column chart_subject_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_chart_subjects_primarykey\n  BEFORE UPDATE ON \"public\".\"chart_subjects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_chart_subjects_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_chart_subjects_into_oplog ON \"public\".\"chart_subjects\";",
      "    CREATE OR REPLACE FUNCTION insert_public_chart_subjects_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'chart_subjects';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'chart_subjects',\n            'INSERT',\n            json_strip_nulls(json_build_object('chart_subject_id', new.\"chart_subject_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'chart_id', new.\"chart_id\", 'chart_subject_id', new.\"chart_subject_id\", 'connect_nulls', new.\"connect_nulls\", 'fill', new.\"fill\", 'fill_graded', new.\"fill_graded\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'name', new.\"name\", 'sort', new.\"sort\", 'stroke', new.\"stroke\", 'table_filter', new.\"table_filter\", 'table_level', new.\"table_level\", 'table_name', new.\"table_name\", 'type', new.\"type\", 'value_field', new.\"value_field\", 'value_source', new.\"value_source\", 'value_unit', new.\"value_unit\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_chart_subjects_into_oplog\n  AFTER INSERT ON \"public\".\"chart_subjects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_chart_subjects_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_chart_subjects_into_oplog ON \"public\".\"chart_subjects\";",
      "    CREATE OR REPLACE FUNCTION update_public_chart_subjects_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'chart_subjects';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'chart_subjects',\n            'UPDATE',\n            json_strip_nulls(json_build_object('chart_subject_id', new.\"chart_subject_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'chart_id', new.\"chart_id\", 'chart_subject_id', new.\"chart_subject_id\", 'connect_nulls', new.\"connect_nulls\", 'fill', new.\"fill\", 'fill_graded', new.\"fill_graded\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'name', new.\"name\", 'sort', new.\"sort\", 'stroke', new.\"stroke\", 'table_filter', new.\"table_filter\", 'table_level', new.\"table_level\", 'table_name', new.\"table_name\", 'type', new.\"type\", 'value_field', new.\"value_field\", 'value_source', new.\"value_source\", 'value_unit', new.\"value_unit\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'chart_id', old.\"chart_id\", 'chart_subject_id', old.\"chart_subject_id\", 'connect_nulls', old.\"connect_nulls\", 'fill', old.\"fill\", 'fill_graded', old.\"fill_graded\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'name', old.\"name\", 'sort', old.\"sort\", 'stroke', old.\"stroke\", 'table_filter', old.\"table_filter\", 'table_level', old.\"table_level\", 'table_name', old.\"table_name\", 'type', old.\"type\", 'value_field', old.\"value_field\", 'value_source', old.\"value_source\", 'value_unit', old.\"value_unit\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_chart_subjects_into_oplog\n  AFTER UPDATE ON \"public\".\"chart_subjects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_chart_subjects_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_chart_subjects_into_oplog ON \"public\".\"chart_subjects\";",
      "    CREATE OR REPLACE FUNCTION delete_public_chart_subjects_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'chart_subjects';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'chart_subjects',\n            'DELETE',\n            json_strip_nulls(json_build_object('chart_subject_id', old.\"chart_subject_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'chart_id', old.\"chart_id\", 'chart_subject_id', old.\"chart_subject_id\", 'connect_nulls', old.\"connect_nulls\", 'fill', old.\"fill\", 'fill_graded', old.\"fill_graded\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'name', old.\"name\", 'sort', old.\"sort\", 'stroke', old.\"stroke\", 'table_filter', old.\"table_filter\", 'table_level', old.\"table_level\", 'table_name', old.\"table_name\", 'type', old.\"type\", 'value_field', old.\"value_field\", 'value_source', old.\"value_source\", 'value_unit', old.\"value_unit\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_chart_subjects_into_oplog\n  AFTER DELETE ON \"public\".\"chart_subjects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_chart_subjects_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_chart_subjects_account_id_into_oplog ON \"public\".\"chart_subjects\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_chart_subjects_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'chart_subjects';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_chart_subjects_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"chart_subjects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_chart_subjects_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_chart_subjects_account_id_into_oplog ON \"public\".\"chart_subjects\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_chart_subjects_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'chart_subjects';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_chart_subjects_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"chart_subjects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_chart_subjects_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_chart_subjects_chart_id_into_oplog ON \"public\".\"chart_subjects\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_chart_subjects_chart_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'chart_subjects';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'charts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('chart_id', \"chart_id\"))),\n            jsonb_build_object('chart_id', \"chart_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"charts\"\n          WHERE \"chart_id\" = NEW.\"chart_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_chart_subjects_chart_id_into_oplog\n  AFTER INSERT ON \"public\".\"chart_subjects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_chart_subjects_chart_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_chart_subjects_chart_id_into_oplog ON \"public\".\"chart_subjects\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_chart_subjects_chart_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'chart_subjects';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'charts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('chart_id', \"chart_id\"))),\n            jsonb_build_object('chart_id', \"chart_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"charts\"\n          WHERE \"chart_id\" = NEW.\"chart_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_chart_subjects_chart_id_into_oplog\n  AFTER UPDATE ON \"public\".\"chart_subjects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_chart_subjects_chart_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_chart_subjects_value_unit_into_oplog ON \"public\".\"chart_subjects\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_chart_subjects_value_unit_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'chart_subjects';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'units',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('unit_id', \"unit_id\"))),\n            jsonb_build_object('unit_id', \"unit_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"units\"\n          WHERE \"unit_id\" = NEW.\"value_unit\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_chart_subjects_value_unit_into_oplog\n  AFTER INSERT ON \"public\".\"chart_subjects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_chart_subjects_value_unit_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_chart_subjects_value_unit_into_oplog ON \"public\".\"chart_subjects\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_chart_subjects_value_unit_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'chart_subjects';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'units',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('unit_id', \"unit_id\"))),\n            jsonb_build_object('unit_id', \"unit_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"units\"\n          WHERE \"unit_id\" = NEW.\"value_unit\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_chart_subjects_value_unit_into_oplog\n  AFTER UPDATE ON \"public\".\"chart_subjects\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_chart_subjects_value_unit_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'crs', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_crs_primarykey ON \"public\".\"crs\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_crs_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"crs_id\" IS DISTINCT FROM NEW.\"crs_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column crs_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_crs_primarykey\n  BEFORE UPDATE ON \"public\".\"crs\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_crs_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_crs_into_oplog ON \"public\".\"crs\";",
      "    CREATE OR REPLACE FUNCTION insert_public_crs_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'crs';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'crs',\n            'INSERT',\n            json_strip_nulls(json_build_object('crs_id', new.\"crs_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'code', new.\"code\", 'crs_id', new.\"crs_id\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'name', new.\"name\", 'proj4', new.\"proj4\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_crs_into_oplog\n  AFTER INSERT ON \"public\".\"crs\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_crs_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_crs_into_oplog ON \"public\".\"crs\";",
      "    CREATE OR REPLACE FUNCTION update_public_crs_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'crs';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'crs',\n            'UPDATE',\n            json_strip_nulls(json_build_object('crs_id', new.\"crs_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'code', new.\"code\", 'crs_id', new.\"crs_id\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'name', new.\"name\", 'proj4', new.\"proj4\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'code', old.\"code\", 'crs_id', old.\"crs_id\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'name', old.\"name\", 'proj4', old.\"proj4\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_crs_into_oplog\n  AFTER UPDATE ON \"public\".\"crs\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_crs_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_crs_into_oplog ON \"public\".\"crs\";",
      "    CREATE OR REPLACE FUNCTION delete_public_crs_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'crs';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'crs',\n            'DELETE',\n            json_strip_nulls(json_build_object('crs_id', old.\"crs_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'code', old.\"code\", 'crs_id', old.\"crs_id\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'name', old.\"name\", 'proj4', old.\"proj4\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_crs_into_oplog\n  AFTER DELETE ON \"public\".\"crs\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_crs_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_crs_account_id_into_oplog ON \"public\".\"crs\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_crs_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'crs';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_crs_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"crs\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_crs_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_crs_account_id_into_oplog ON \"public\".\"crs\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_crs_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'crs';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_crs_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"crs\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_crs_account_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'project_crs', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_project_crs_primarykey ON \"public\".\"project_crs\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_project_crs_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"project_crs_id\" IS DISTINCT FROM NEW.\"project_crs_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column project_crs_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_project_crs_primarykey\n  BEFORE UPDATE ON \"public\".\"project_crs\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_project_crs_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_project_crs_into_oplog ON \"public\".\"project_crs\";",
      "    CREATE OR REPLACE FUNCTION insert_public_project_crs_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_crs';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'project_crs',\n            'INSERT',\n            json_strip_nulls(json_build_object('project_crs_id', new.\"project_crs_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'code', new.\"code\", 'crs_id', new.\"crs_id\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'name', new.\"name\", 'proj4', new.\"proj4\", 'project_crs_id', new.\"project_crs_id\", 'project_id', new.\"project_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_project_crs_into_oplog\n  AFTER INSERT ON \"public\".\"project_crs\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_project_crs_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_project_crs_into_oplog ON \"public\".\"project_crs\";",
      "    CREATE OR REPLACE FUNCTION update_public_project_crs_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_crs';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'project_crs',\n            'UPDATE',\n            json_strip_nulls(json_build_object('project_crs_id', new.\"project_crs_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'code', new.\"code\", 'crs_id', new.\"crs_id\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'name', new.\"name\", 'proj4', new.\"proj4\", 'project_crs_id', new.\"project_crs_id\", 'project_id', new.\"project_id\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'code', old.\"code\", 'crs_id', old.\"crs_id\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'name', old.\"name\", 'proj4', old.\"proj4\", 'project_crs_id', old.\"project_crs_id\", 'project_id', old.\"project_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_project_crs_into_oplog\n  AFTER UPDATE ON \"public\".\"project_crs\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_project_crs_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_project_crs_into_oplog ON \"public\".\"project_crs\";",
      "    CREATE OR REPLACE FUNCTION delete_public_project_crs_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_crs';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'project_crs',\n            'DELETE',\n            json_strip_nulls(json_build_object('project_crs_id', old.\"project_crs_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'code', old.\"code\", 'crs_id', old.\"crs_id\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'name', old.\"name\", 'proj4', old.\"proj4\", 'project_crs_id', old.\"project_crs_id\", 'project_id', old.\"project_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_project_crs_into_oplog\n  AFTER DELETE ON \"public\".\"project_crs\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_project_crs_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_project_crs_account_id_into_oplog ON \"public\".\"project_crs\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_project_crs_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_crs';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_project_crs_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"project_crs\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_project_crs_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_project_crs_account_id_into_oplog ON \"public\".\"project_crs\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_project_crs_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_crs';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_project_crs_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"project_crs\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_project_crs_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_project_crs_crs_id_into_oplog ON \"public\".\"project_crs\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_project_crs_crs_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_crs';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'crs',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('crs_id', \"crs_id\"))),\n            jsonb_build_object('crs_id', \"crs_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"crs\"\n          WHERE \"crs_id\" = NEW.\"crs_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_project_crs_crs_id_into_oplog\n  AFTER INSERT ON \"public\".\"project_crs\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_project_crs_crs_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_project_crs_crs_id_into_oplog ON \"public\".\"project_crs\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_project_crs_crs_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_crs';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'crs',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('crs_id', \"crs_id\"))),\n            jsonb_build_object('crs_id', \"crs_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"crs\"\n          WHERE \"crs_id\" = NEW.\"crs_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_project_crs_crs_id_into_oplog\n  AFTER UPDATE ON \"public\".\"project_crs\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_project_crs_crs_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_project_crs_project_id_into_oplog ON \"public\".\"project_crs\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_project_crs_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_crs';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_project_crs_project_id_into_oplog\n  AFTER INSERT ON \"public\".\"project_crs\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_project_crs_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_project_crs_project_id_into_oplog ON \"public\".\"project_crs\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_project_crs_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'project_crs';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_project_crs_project_id_into_oplog\n  AFTER UPDATE ON \"public\".\"project_crs\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_project_crs_project_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'layer_presentations', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_layer_presentations_primarykey ON \"public\".\"layer_presentations\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_layer_presentations_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"layer_presentation_id\" IS DISTINCT FROM NEW.\"layer_presentation_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column layer_presentation_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_layer_presentations_primarykey\n  BEFORE UPDATE ON \"public\".\"layer_presentations\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_layer_presentations_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_layer_presentations_into_oplog ON \"public\".\"layer_presentations\";",
      "    CREATE OR REPLACE FUNCTION insert_public_layer_presentations_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'layer_presentations';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'layer_presentations',\n            'INSERT',\n            json_strip_nulls(json_build_object('layer_presentation_id', new.\"layer_presentation_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'active', new.\"active\", 'grayscale', new.\"grayscale\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'layer_presentation_id', new.\"layer_presentation_id\", 'max_zoom', new.\"max_zoom\", 'min_zoom', new.\"min_zoom\", 'opacity_percent', new.\"opacity_percent\", 'transparent', new.\"transparent\", 'vector_layer_id', new.\"vector_layer_id\", 'wms_layer_id', new.\"wms_layer_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_layer_presentations_into_oplog\n  AFTER INSERT ON \"public\".\"layer_presentations\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_layer_presentations_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_layer_presentations_into_oplog ON \"public\".\"layer_presentations\";",
      "    CREATE OR REPLACE FUNCTION update_public_layer_presentations_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'layer_presentations';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'layer_presentations',\n            'UPDATE',\n            json_strip_nulls(json_build_object('layer_presentation_id', new.\"layer_presentation_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'active', new.\"active\", 'grayscale', new.\"grayscale\", 'label_replace_by_generated_column', new.\"label_replace_by_generated_column\", 'layer_presentation_id', new.\"layer_presentation_id\", 'max_zoom', new.\"max_zoom\", 'min_zoom', new.\"min_zoom\", 'opacity_percent', new.\"opacity_percent\", 'transparent', new.\"transparent\", 'vector_layer_id', new.\"vector_layer_id\", 'wms_layer_id', new.\"wms_layer_id\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'active', old.\"active\", 'grayscale', old.\"grayscale\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'layer_presentation_id', old.\"layer_presentation_id\", 'max_zoom', old.\"max_zoom\", 'min_zoom', old.\"min_zoom\", 'opacity_percent', old.\"opacity_percent\", 'transparent', old.\"transparent\", 'vector_layer_id', old.\"vector_layer_id\", 'wms_layer_id', old.\"wms_layer_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_layer_presentations_into_oplog\n  AFTER UPDATE ON \"public\".\"layer_presentations\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_layer_presentations_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_layer_presentations_into_oplog ON \"public\".\"layer_presentations\";",
      "    CREATE OR REPLACE FUNCTION delete_public_layer_presentations_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'layer_presentations';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'layer_presentations',\n            'DELETE',\n            json_strip_nulls(json_build_object('layer_presentation_id', old.\"layer_presentation_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'active', old.\"active\", 'grayscale', old.\"grayscale\", 'label_replace_by_generated_column', old.\"label_replace_by_generated_column\", 'layer_presentation_id', old.\"layer_presentation_id\", 'max_zoom', old.\"max_zoom\", 'min_zoom', old.\"min_zoom\", 'opacity_percent', old.\"opacity_percent\", 'transparent', old.\"transparent\", 'vector_layer_id', old.\"vector_layer_id\", 'wms_layer_id', old.\"wms_layer_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_layer_presentations_into_oplog\n  AFTER DELETE ON \"public\".\"layer_presentations\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_layer_presentations_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_layer_presentations_account_id_into_oplog ON \"public\".\"layer_presentations\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_layer_presentations_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'layer_presentations';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_layer_presentations_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"layer_presentations\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_layer_presentations_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_layer_presentations_account_id_into_oplog ON \"public\".\"layer_presentations\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_layer_presentations_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'layer_presentations';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_layer_presentations_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"layer_presentations\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_layer_presentations_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_layer_presentations_vector_layer_id_into_oplog ON \"public\".\"layer_presentations\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_layer_presentations_vector_layer_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'layer_presentations';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'vector_layers',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('vector_layer_id', \"vector_layer_id\"))),\n            jsonb_build_object('vector_layer_id', \"vector_layer_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"vector_layers\"\n          WHERE \"vector_layer_id\" = NEW.\"vector_layer_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_layer_presentations_vector_layer_id_into_oplog\n  AFTER INSERT ON \"public\".\"layer_presentations\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_layer_presentations_vector_layer_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_layer_presentations_vector_layer_id_into_oplog ON \"public\".\"layer_presentations\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_layer_presentations_vector_layer_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'layer_presentations';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'vector_layers',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('vector_layer_id', \"vector_layer_id\"))),\n            jsonb_build_object('vector_layer_id', \"vector_layer_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"vector_layers\"\n          WHERE \"vector_layer_id\" = NEW.\"vector_layer_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_layer_presentations_vector_layer_id_into_oplog\n  AFTER UPDATE ON \"public\".\"layer_presentations\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_layer_presentations_vector_layer_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_layer_presentations_wms_layer_id_into_oplog ON \"public\".\"layer_presentations\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_layer_presentations_wms_layer_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'layer_presentations';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'wms_layers',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('wms_layer_id', \"wms_layer_id\"))),\n            jsonb_build_object('wms_layer_id', \"wms_layer_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"wms_layers\"\n          WHERE \"wms_layer_id\" = NEW.\"wms_layer_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_layer_presentations_wms_layer_id_into_oplog\n  AFTER INSERT ON \"public\".\"layer_presentations\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_layer_presentations_wms_layer_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_layer_presentations_wms_layer_id_into_oplog ON \"public\".\"layer_presentations\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_layer_presentations_wms_layer_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'layer_presentations';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'wms_layers',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('wms_layer_id', \"wms_layer_id\"))),\n            jsonb_build_object('wms_layer_id', \"wms_layer_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"wms_layers\"\n          WHERE \"wms_layer_id\" = NEW.\"wms_layer_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_layer_presentations_wms_layer_id_into_oplog\n  AFTER UPDATE ON \"public\".\"layer_presentations\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_layer_presentations_wms_layer_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'wms_services', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_wms_services_primarykey ON \"public\".\"wms_services\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_wms_services_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"wms_service_id\" IS DISTINCT FROM NEW.\"wms_service_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column wms_service_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_wms_services_primarykey\n  BEFORE UPDATE ON \"public\".\"wms_services\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_wms_services_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_wms_services_into_oplog ON \"public\".\"wms_services\";",
      "    CREATE OR REPLACE FUNCTION insert_public_wms_services_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_services';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'wms_services',\n            'INSERT',\n            json_strip_nulls(json_build_object('wms_service_id', new.\"wms_service_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'default_crs', new.\"default_crs\", 'image_format', new.\"image_format\", 'image_formats', new.\"image_formats\", 'info_format', new.\"info_format\", 'info_formats', new.\"info_formats\", 'project_id', new.\"project_id\", 'url', new.\"url\", 'version', new.\"version\", 'wms_service_id', new.\"wms_service_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_wms_services_into_oplog\n  AFTER INSERT ON \"public\".\"wms_services\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_wms_services_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_wms_services_into_oplog ON \"public\".\"wms_services\";",
      "    CREATE OR REPLACE FUNCTION update_public_wms_services_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_services';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'wms_services',\n            'UPDATE',\n            json_strip_nulls(json_build_object('wms_service_id', new.\"wms_service_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'default_crs', new.\"default_crs\", 'image_format', new.\"image_format\", 'image_formats', new.\"image_formats\", 'info_format', new.\"info_format\", 'info_formats', new.\"info_formats\", 'project_id', new.\"project_id\", 'url', new.\"url\", 'version', new.\"version\", 'wms_service_id', new.\"wms_service_id\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'default_crs', old.\"default_crs\", 'image_format', old.\"image_format\", 'image_formats', old.\"image_formats\", 'info_format', old.\"info_format\", 'info_formats', old.\"info_formats\", 'project_id', old.\"project_id\", 'url', old.\"url\", 'version', old.\"version\", 'wms_service_id', old.\"wms_service_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_wms_services_into_oplog\n  AFTER UPDATE ON \"public\".\"wms_services\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_wms_services_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_wms_services_into_oplog ON \"public\".\"wms_services\";",
      "    CREATE OR REPLACE FUNCTION delete_public_wms_services_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_services';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'wms_services',\n            'DELETE',\n            json_strip_nulls(json_build_object('wms_service_id', old.\"wms_service_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'default_crs', old.\"default_crs\", 'image_format', old.\"image_format\", 'image_formats', old.\"image_formats\", 'info_format', old.\"info_format\", 'info_formats', old.\"info_formats\", 'project_id', old.\"project_id\", 'url', old.\"url\", 'version', old.\"version\", 'wms_service_id', old.\"wms_service_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_wms_services_into_oplog\n  AFTER DELETE ON \"public\".\"wms_services\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_wms_services_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_wms_services_account_id_into_oplog ON \"public\".\"wms_services\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_wms_services_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_services';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_wms_services_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"wms_services\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_wms_services_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_wms_services_account_id_into_oplog ON \"public\".\"wms_services\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_wms_services_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_services';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_wms_services_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"wms_services\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_wms_services_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_wms_services_project_id_into_oplog ON \"public\".\"wms_services\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_wms_services_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_services';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_wms_services_project_id_into_oplog\n  AFTER INSERT ON \"public\".\"wms_services\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_wms_services_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_wms_services_project_id_into_oplog ON \"public\".\"wms_services\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_wms_services_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_services';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_wms_services_project_id_into_oplog\n  AFTER UPDATE ON \"public\".\"wms_services\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_wms_services_project_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'wms_service_layers', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_wms_service_layers_primarykey ON \"public\".\"wms_service_layers\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_wms_service_layers_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"wms_service_layer_id\" IS DISTINCT FROM NEW.\"wms_service_layer_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column wms_service_layer_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_wms_service_layers_primarykey\n  BEFORE UPDATE ON \"public\".\"wms_service_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_wms_service_layers_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_wms_service_layers_into_oplog ON \"public\".\"wms_service_layers\";",
      "    CREATE OR REPLACE FUNCTION insert_public_wms_service_layers_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_service_layers';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'wms_service_layers',\n            'INSERT',\n            json_strip_nulls(json_build_object('wms_service_layer_id', new.\"wms_service_layer_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label', new.\"label\", 'legend_image', CASE WHEN new.\"legend_image\" IS NOT NULL THEN encode(new.\"legend_image\"::bytea, 'hex') ELSE NULL END, 'legend_url', new.\"legend_url\", 'name', new.\"name\", 'queryable', new.\"queryable\", 'wms_service_id', new.\"wms_service_id\", 'wms_service_layer_id', new.\"wms_service_layer_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_wms_service_layers_into_oplog\n  AFTER INSERT ON \"public\".\"wms_service_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_wms_service_layers_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_wms_service_layers_into_oplog ON \"public\".\"wms_service_layers\";",
      "    CREATE OR REPLACE FUNCTION update_public_wms_service_layers_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_service_layers';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'wms_service_layers',\n            'UPDATE',\n            json_strip_nulls(json_build_object('wms_service_layer_id', new.\"wms_service_layer_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label', new.\"label\", 'legend_image', CASE WHEN new.\"legend_image\" IS NOT NULL THEN encode(new.\"legend_image\"::bytea, 'hex') ELSE NULL END, 'legend_url', new.\"legend_url\", 'name', new.\"name\", 'queryable', new.\"queryable\", 'wms_service_id', new.\"wms_service_id\", 'wms_service_layer_id', new.\"wms_service_layer_id\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'label', old.\"label\", 'legend_image', CASE WHEN old.\"legend_image\" IS NOT NULL THEN encode(old.\"legend_image\"::bytea, 'hex') ELSE NULL END, 'legend_url', old.\"legend_url\", 'name', old.\"name\", 'queryable', old.\"queryable\", 'wms_service_id', old.\"wms_service_id\", 'wms_service_layer_id', old.\"wms_service_layer_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_wms_service_layers_into_oplog\n  AFTER UPDATE ON \"public\".\"wms_service_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_wms_service_layers_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_wms_service_layers_into_oplog ON \"public\".\"wms_service_layers\";",
      "    CREATE OR REPLACE FUNCTION delete_public_wms_service_layers_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_service_layers';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'wms_service_layers',\n            'DELETE',\n            json_strip_nulls(json_build_object('wms_service_layer_id', old.\"wms_service_layer_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'label', old.\"label\", 'legend_image', CASE WHEN old.\"legend_image\" IS NOT NULL THEN encode(old.\"legend_image\"::bytea, 'hex') ELSE NULL END, 'legend_url', old.\"legend_url\", 'name', old.\"name\", 'queryable', old.\"queryable\", 'wms_service_id', old.\"wms_service_id\", 'wms_service_layer_id', old.\"wms_service_layer_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_wms_service_layers_into_oplog\n  AFTER DELETE ON \"public\".\"wms_service_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_wms_service_layers_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_wms_service_layers_account_id_into_oplog ON \"public\".\"wms_service_layers\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_wms_service_layers_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_service_layers';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_wms_service_layers_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"wms_service_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_wms_service_layers_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_wms_service_layers_account_id_into_oplog ON \"public\".\"wms_service_layers\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_wms_service_layers_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_service_layers';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_wms_service_layers_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"wms_service_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_wms_service_layers_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_wms_service_layers_wms_service_id_into_oplog ON \"public\".\"wms_service_layers\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_wms_service_layers_wms_service_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_service_layers';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'wms_services',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('wms_service_id', \"wms_service_id\"))),\n            jsonb_build_object('wms_service_id', \"wms_service_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"wms_services\"\n          WHERE \"wms_service_id\" = NEW.\"wms_service_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_wms_service_layers_wms_service_id_into_oplog\n  AFTER INSERT ON \"public\".\"wms_service_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_wms_service_layers_wms_service_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_wms_service_layers_wms_service_id_into_oplog ON \"public\".\"wms_service_layers\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_wms_service_layers_wms_service_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wms_service_layers';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'wms_services',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('wms_service_id', \"wms_service_id\"))),\n            jsonb_build_object('wms_service_id', \"wms_service_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"wms_services\"\n          WHERE \"wms_service_id\" = NEW.\"wms_service_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_wms_service_layers_wms_service_id_into_oplog\n  AFTER UPDATE ON \"public\".\"wms_service_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_wms_service_layers_wms_service_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'wfs_services', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_wfs_services_primarykey ON \"public\".\"wfs_services\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_wfs_services_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"wfs_service_id\" IS DISTINCT FROM NEW.\"wfs_service_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column wfs_service_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_wfs_services_primarykey\n  BEFORE UPDATE ON \"public\".\"wfs_services\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_wfs_services_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_wfs_services_into_oplog ON \"public\".\"wfs_services\";",
      "    CREATE OR REPLACE FUNCTION insert_public_wfs_services_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wfs_services';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'wfs_services',\n            'INSERT',\n            json_strip_nulls(json_build_object('wfs_service_id', new.\"wfs_service_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'default_crs', new.\"default_crs\", 'info_format', new.\"info_format\", 'info_formats', new.\"info_formats\", 'project_id', new.\"project_id\", 'url', new.\"url\", 'version', new.\"version\", 'wfs_service_id', new.\"wfs_service_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_wfs_services_into_oplog\n  AFTER INSERT ON \"public\".\"wfs_services\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_wfs_services_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_wfs_services_into_oplog ON \"public\".\"wfs_services\";",
      "    CREATE OR REPLACE FUNCTION update_public_wfs_services_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wfs_services';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'wfs_services',\n            'UPDATE',\n            json_strip_nulls(json_build_object('wfs_service_id', new.\"wfs_service_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'default_crs', new.\"default_crs\", 'info_format', new.\"info_format\", 'info_formats', new.\"info_formats\", 'project_id', new.\"project_id\", 'url', new.\"url\", 'version', new.\"version\", 'wfs_service_id', new.\"wfs_service_id\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'default_crs', old.\"default_crs\", 'info_format', old.\"info_format\", 'info_formats', old.\"info_formats\", 'project_id', old.\"project_id\", 'url', old.\"url\", 'version', old.\"version\", 'wfs_service_id', old.\"wfs_service_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_wfs_services_into_oplog\n  AFTER UPDATE ON \"public\".\"wfs_services\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_wfs_services_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_wfs_services_into_oplog ON \"public\".\"wfs_services\";",
      "    CREATE OR REPLACE FUNCTION delete_public_wfs_services_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wfs_services';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'wfs_services',\n            'DELETE',\n            json_strip_nulls(json_build_object('wfs_service_id', old.\"wfs_service_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'default_crs', old.\"default_crs\", 'info_format', old.\"info_format\", 'info_formats', old.\"info_formats\", 'project_id', old.\"project_id\", 'url', old.\"url\", 'version', old.\"version\", 'wfs_service_id', old.\"wfs_service_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_wfs_services_into_oplog\n  AFTER DELETE ON \"public\".\"wfs_services\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_wfs_services_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_wfs_services_account_id_into_oplog ON \"public\".\"wfs_services\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_wfs_services_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wfs_services';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_wfs_services_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"wfs_services\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_wfs_services_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_wfs_services_account_id_into_oplog ON \"public\".\"wfs_services\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_wfs_services_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wfs_services';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_wfs_services_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"wfs_services\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_wfs_services_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_wfs_services_project_id_into_oplog ON \"public\".\"wfs_services\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_wfs_services_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wfs_services';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_wfs_services_project_id_into_oplog\n  AFTER INSERT ON \"public\".\"wfs_services\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_wfs_services_project_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_wfs_services_project_id_into_oplog ON \"public\".\"wfs_services\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_wfs_services_project_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wfs_services';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'projects',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('project_id', \"project_id\"))),\n            jsonb_build_object('project_id', \"project_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"projects\"\n          WHERE \"project_id\" = NEW.\"project_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_wfs_services_project_id_into_oplog\n  AFTER UPDATE ON \"public\".\"wfs_services\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_wfs_services_project_id_into_oplog_function();",
      "INSERT INTO \"public\".\"_electric_trigger_settings\" (\"namespace\", \"tablename\", \"flag\")\n  VALUES ('public', 'wfs_service_layers', 1)\n  ON CONFLICT DO NOTHING;",
      "DROP TRIGGER IF EXISTS update_ensure_public_wfs_service_layers_primarykey ON \"public\".\"wfs_service_layers\";",
      "CREATE OR REPLACE FUNCTION update_ensure_public_wfs_service_layers_primarykey_function()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF OLD.\"wfs_service_layer_id\" IS DISTINCT FROM NEW.\"wfs_service_layer_id\" THEN\n    RAISE EXCEPTION 'Cannot change the value of column wfs_service_layer_id as it belongs to the primary key';\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_ensure_public_wfs_service_layers_primarykey\n  BEFORE UPDATE ON \"public\".\"wfs_service_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_ensure_public_wfs_service_layers_primarykey_function();",
      "DROP TRIGGER IF EXISTS insert_public_wfs_service_layers_into_oplog ON \"public\".\"wfs_service_layers\";",
      "    CREATE OR REPLACE FUNCTION insert_public_wfs_service_layers_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wfs_service_layers';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'wfs_service_layers',\n            'INSERT',\n            json_strip_nulls(json_build_object('wfs_service_layer_id', new.\"wfs_service_layer_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label', new.\"label\", 'name', new.\"name\", 'wfs_service_id', new.\"wfs_service_id\", 'wfs_service_layer_id', new.\"wfs_service_layer_id\"),\n            NULL,\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER insert_public_wfs_service_layers_into_oplog\n  AFTER INSERT ON \"public\".\"wfs_service_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION insert_public_wfs_service_layers_into_oplog_function();",
      "DROP TRIGGER IF EXISTS update_public_wfs_service_layers_into_oplog ON \"public\".\"wfs_service_layers\";",
      "    CREATE OR REPLACE FUNCTION update_public_wfs_service_layers_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wfs_service_layers';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'wfs_service_layers',\n            'UPDATE',\n            json_strip_nulls(json_build_object('wfs_service_layer_id', new.\"wfs_service_layer_id\")),\n            jsonb_build_object('account_id', new.\"account_id\", 'label', new.\"label\", 'name', new.\"name\", 'wfs_service_id', new.\"wfs_service_id\", 'wfs_service_layer_id', new.\"wfs_service_layer_id\"),\n            jsonb_build_object('account_id', old.\"account_id\", 'label', old.\"label\", 'name', old.\"name\", 'wfs_service_id', old.\"wfs_service_id\", 'wfs_service_layer_id', old.\"wfs_service_layer_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER update_public_wfs_service_layers_into_oplog\n  AFTER UPDATE ON \"public\".\"wfs_service_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION update_public_wfs_service_layers_into_oplog_function();",
      "DROP TRIGGER IF EXISTS delete_public_wfs_service_layers_into_oplog ON \"public\".\"wfs_service_layers\";",
      "    CREATE OR REPLACE FUNCTION delete_public_wfs_service_layers_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n      BEGIN\n        -- Get the flag value from _electric_trigger_settings\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wfs_service_layers';\n\n        IF flag_value = 1 THEN\n          -- Insert into _electric_oplog\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          VALUES (\n            'public',\n            'wfs_service_layers',\n            'DELETE',\n            json_strip_nulls(json_build_object('wfs_service_layer_id', old.\"wfs_service_layer_id\")),\n            NULL,\n            jsonb_build_object('account_id', old.\"account_id\", 'label', old.\"label\", 'name', old.\"name\", 'wfs_service_id', old.\"wfs_service_id\", 'wfs_service_layer_id', old.\"wfs_service_layer_id\"),\n            NULL\n          );\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER delete_public_wfs_service_layers_into_oplog\n  AFTER DELETE ON \"public\".\"wfs_service_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION delete_public_wfs_service_layers_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_wfs_service_layers_account_id_into_oplog ON \"public\".\"wfs_service_layers\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_wfs_service_layers_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wfs_service_layers';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_wfs_service_layers_account_id_into_oplog\n  AFTER INSERT ON \"public\".\"wfs_service_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_wfs_service_layers_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_wfs_service_layers_account_id_into_oplog ON \"public\".\"wfs_service_layers\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_wfs_service_layers_account_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wfs_service_layers';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'accounts',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('account_id', \"account_id\"))),\n            jsonb_build_object('account_id', \"account_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"accounts\"\n          WHERE \"account_id\" = NEW.\"account_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_wfs_service_layers_account_id_into_oplog\n  AFTER UPDATE ON \"public\".\"wfs_service_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_wfs_service_layers_account_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_insert_public_wfs_service_layers_wfs_service_id_into_oplog ON \"public\".\"wfs_service_layers\";",
      "    CREATE OR REPLACE FUNCTION compensation_insert_public_wfs_service_layers_wfs_service_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wfs_service_layers';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'wfs_services',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('wfs_service_id', \"wfs_service_id\"))),\n            jsonb_build_object('wfs_service_id', \"wfs_service_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"wfs_services\"\n          WHERE \"wfs_service_id\" = NEW.\"wfs_service_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_insert_public_wfs_service_layers_wfs_service_id_into_oplog\n  AFTER INSERT ON \"public\".\"wfs_service_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_insert_public_wfs_service_layers_wfs_service_id_into_oplog_function();",
      "DROP TRIGGER IF EXISTS compensation_update_public_wfs_service_layers_wfs_service_id_into_oplog ON \"public\".\"wfs_service_layers\";",
      "    CREATE OR REPLACE FUNCTION compensation_update_public_wfs_service_layers_wfs_service_id_into_oplog_function()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      DECLARE\n        flag_value INTEGER;\n        meta_value INTEGER;\n      BEGIN\n        SELECT flag INTO flag_value FROM \"public\"._electric_trigger_settings WHERE namespace = 'public' AND tablename = 'wfs_service_layers';\n\n        SELECT value INTO meta_value FROM \"public\"._electric_meta WHERE key = 'compensations';\n\n        IF flag_value = 1 AND meta_value = 1 THEN\n          INSERT INTO \"public\"._electric_oplog (namespace, tablename, optype, \"primaryKey\", \"newRow\", \"oldRow\", timestamp)\n          SELECT\n            'public',\n            'wfs_services',\n            'COMPENSATION',\n            json_strip_nulls(json_strip_nulls(json_build_object('wfs_service_id', \"wfs_service_id\"))),\n            jsonb_build_object('wfs_service_id', \"wfs_service_id\"),\n            NULL,\n            NULL\n          FROM \"public\".\"wfs_services\"\n          WHERE \"wfs_service_id\" = NEW.\"wfs_service_id\";\n        END IF;\n\n        RETURN NEW;\n      END;\n    END;\n    $$ LANGUAGE plpgsql;",
      "CREATE TRIGGER compensation_update_public_wfs_service_layers_wfs_service_id_into_oplog\n  AFTER UPDATE ON \"public\".\"wfs_service_layers\"\n    FOR EACH ROW\n      EXECUTE FUNCTION compensation_update_public_wfs_service_layers_wfs_service_id_into_oplog_function();"
    ],
    "version": "1"
  }
]